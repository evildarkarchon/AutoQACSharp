---
description: Development workflow, porting guidelines, and testing requirements
globs:
  - "**/*.cs"
  - "**/*.axaml"
---

# Development Workflow

## Implementation Order

Follow this order when implementing features:

1. **Reference Implementation**: Check `Code_To_Port/` for equivalent functionality
2. **Design C# Equivalent**: Translate concepts to C#/Avalonia patterns
3. **Implement Models First**: Business logic before UI
4. **Build ViewModels**: Presentation logic with ReactiveUI
5. **Create Views Last**: XAML UI with data binding
6. **Test Incrementally**: Verify each layer before moving on
7. **Maintain Sequential Processing**: Always process plugins one at a time

## Porting from Reference Implementation

When porting functionality from `Code_To_Port/`:

### Study the Reference First

- Read `Code_To_Port/CLAUDE.md` for architecture overview
- Examine the Python modules in `Code_To_Port/AutoQACLib/`
- Understand the state management and threading model

### Translation Mappings

| Python/Qt | C# Avalonia |
|-----------|-------------|
| `StateManager` with Qt signals | ReactiveUI `ReactiveObject` properties |
| `QThread` worker | `Task.Run()` or `ReactiveCommand.CreateFromTask()` |
| `QMutex` | `SemaphoreSlim` or async patterns |
| Python signals/slots | ReactiveUI observables |
| `ConfigManager` YAML I/O | `YamlDotNet` for YAML serialization |
| `CleaningService` subprocess | `Process.Start()` with async output reading |
| `GuiController` mediator | ViewModel orchestration |
| PySide6 dialogs | Avalonia `Window` with MVVM |

### Translate Concepts, Not Code

Don't copy Python code line-by-line. Instead:
- Understand what the Python code is trying to achieve
- Implement the same behavior using idiomatic C# patterns
- Use async/await instead of threads where appropriate

## Testing Requirements

### Framework

- **xUnit**: Test framework
- **FluentAssertions**: Assertion library
- **NSubstitute** or **Moq**: Mocking

### Test Categories

- **Unit Tests**: Test ViewModels and Models independently
- **Integration Tests**: Test file I/O and subprocess execution
- **UI Tests**: Consider Avalonia.Headless for automated UI testing

### Coverage Target

Minimum **80%** coverage for critical paths:
- Cleaning logic
- Plugin validation
- Configuration management

### Test Structure

```csharp
public class CleaningServiceTests
{
    private readonly ICleaningService _sut;
    private readonly IProcessExecutionService _processService;

    public CleaningServiceTests()
    {
        _processService = Substitute.For<IProcessExecutionService>();
        _sut = new CleaningService(_processService);
    }

    [Fact]
    public async Task CleanPluginAsync_ValidPlugin_ReturnsSuccess()
    {
        // Arrange
        _processService.ExecuteAsync(Arg.Any<ProcessStartInfo>())
            .Returns(new ProcessResult { ExitCode = 0 });

        // Act
        var result = await _sut.CleanPluginAsync("test.esp", CancellationToken.None);

        // Assert
        result.Should().BeSuccessful();
    }
}
```

## Common Pitfalls to Avoid

1. **Parallel Processing**: NEVER attempt to clean multiple plugins simultaneously
2. **UI Thread Deadlocks**: Always use `async/await`, never `.Result` or `.Wait()`
3. **Memory Leaks**: Dispose of `IDisposable` objects, especially event subscriptions
4. **Mixing MVVM Layers**: Keep Models, ViewModels, and Views strictly separated
5. **Blocking Operations**: Never block the UI thread; use `Task.Run()` or async commands
6. **Improper Binding**: Use compiled bindings; avoid string-based bindings
7. **Static State**: Avoid static mutable state; use dependency injection
8. **Exception Swallowing**: Always log exceptions and handle them gracefully
