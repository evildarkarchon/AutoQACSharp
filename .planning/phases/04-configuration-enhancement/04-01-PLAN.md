---
phase: 04-configuration-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Models/Configuration/RetentionSettings.cs
  - AutoQAC/Models/Configuration/UserConfiguration.cs
  - AutoQAC/Services/Configuration/IConfigurationService.cs
  - AutoQAC/Services/Configuration/ConfigurationService.cs
  - AutoQAC/Services/Configuration/IConfigWatcherService.cs
  - AutoQAC/Services/Configuration/ConfigWatcherService.cs
  - AutoQAC/Services/Configuration/ILegacyMigrationService.cs
  - AutoQAC/Services/Configuration/LegacyMigrationService.cs
  - AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  - AutoQAC/App.axaml.cs
  - AutoQAC/ViewModels/MainWindowViewModel.cs
autonomous: true

must_haves:
  truths:
    - "YAML config is re-read from disk only when the file content has actually changed (hash comparison)"
    - "Config changes detected during an active cleaning session are deferred until the session ends"
    - "App-initiated config saves do not trigger the watcher to reload (no circular reload loop)"
    - "Legacy Python config files are migrated safely with backup-then-delete order"
    - "Migration failures produce a non-modal warning banner in the main window"
    - "Migration only runs when no C# config exists -- one-time bootstrap, not a merge"
    - "IConfigurationService exposes GetAllSettingsAsync and UpdateMultipleAsync batch helpers"
  artifacts:
    - path: "AutoQAC/Models/Configuration/RetentionSettings.cs"
      provides: "RetentionMode enum (AgeBased/CountBased) and RetentionSettings model"
      contains: "RetentionMode"
    - path: "AutoQAC/Services/Configuration/IConfigWatcherService.cs"
      provides: "Interface for config file change detection"
      exports: ["IConfigWatcherService"]
    - path: "AutoQAC/Services/Configuration/ConfigWatcherService.cs"
      provides: "FSW + SHA256 hash-based config reload with cleaning-session deferral"
      contains: "SHA256"
    - path: "AutoQAC/Services/Configuration/ILegacyMigrationService.cs"
      provides: "Interface for legacy migration with result observable"
      exports: ["ILegacyMigrationService"]
    - path: "AutoQAC/Services/Configuration/LegacyMigrationService.cs"
      provides: "Migration logic: detect, validate, backup, migrate, delete"
      contains: "migration_backup"
  key_links:
    - from: "AutoQAC/Services/Configuration/ConfigWatcherService.cs"
      to: "AutoQAC/Services/Configuration/ConfigurationService.cs"
      via: "Calls ReloadFromDiskAsync or IConfigurationService method to reload"
      pattern: "ReloadFromDisk|LoadUserConfigAsync"
    - from: "AutoQAC/Services/Configuration/ConfigWatcherService.cs"
      to: "AutoQAC/Services/State/IStateService.cs"
      via: "Subscribes to IsCleaning to defer reloads"
      pattern: "IsCleaning|StateChanged"
    - from: "AutoQAC/Services/Configuration/ConfigurationService.cs"
      to: "AutoQAC/Services/Configuration/ConfigWatcherService.cs"
      via: "Updates lastKnownHash after app-initiated save to prevent circular reload"
      pattern: "_lastKnownHash|NotifyAppSave"
    - from: "AutoQAC/App.axaml.cs"
      to: "AutoQAC/Services/Configuration/ILegacyMigrationService.cs"
      via: "Runs migration on startup, wires result to MainWindowViewModel"
      pattern: "MigrateAsync|ILegacyMigrationService"
---

<objective>
Build the backend service infrastructure for Phase 4: config watcher service (CONF-04), legacy migration rewrite (CONF-06), config helper methods (CONF-03), and RetentionSettings model (CONF-07 data model).

Purpose: These services are the foundation that Plan 04-02's UI consumes. The config watcher enables silent reload when users edit YAML externally. The migration service safely handles Python-era config files. The helper methods and retention model support the Settings UI expansion.

Output: Four new service files (watcher + migration, interfaces + implementations), extended ConfigurationService, RetentionSettings model, updated DI registration, migration banner wiring in MainWindowViewModel.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-configuration-enhancement/04-CONTEXT.md
@.planning/phases/04-configuration-enhancement/04-RESEARCH.md
@AutoQAC/Services/Configuration/IConfigurationService.cs
@AutoQAC/Services/Configuration/ConfigurationService.cs
@AutoQAC/Models/Configuration/UserConfiguration.cs
@AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
@AutoQAC/App.axaml.cs
@AutoQAC/ViewModels/MainWindowViewModel.cs
@AutoQAC/Services/State/IStateService.cs
@AutoQAC/Infrastructure/Logging/LoggingService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RetentionSettings model, config helpers, and config watcher service</name>
  <files>
    AutoQAC/Models/Configuration/RetentionSettings.cs
    AutoQAC/Models/Configuration/UserConfiguration.cs
    AutoQAC/Services/Configuration/IConfigurationService.cs
    AutoQAC/Services/Configuration/ConfigurationService.cs
    AutoQAC/Services/Configuration/IConfigWatcherService.cs
    AutoQAC/Services/Configuration/ConfigWatcherService.cs
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  </files>
  <action>
    **1. Create RetentionSettings model** (`AutoQAC/Models/Configuration/RetentionSettings.cs`):
    - Create `RetentionMode` enum: `AgeBased`, `CountBased`
    - Create `RetentionSettings` class with YamlDotNet aliases:
      - `RetentionMode Mode` (default: `AgeBased`)
      - `int MaxAgeDays` (default: 30)
      - `int MaxFileCount` (default: 50)
    - Use `[YamlMember(Alias = "...")]` attributes matching the project's snake_case YAML convention

    **2. Extend UserConfiguration** (`AutoQAC/Models/Configuration/UserConfiguration.cs`):
    - Add `[YamlMember(Alias = "Log_Retention")] public RetentionSettings LogRetention { get; set; } = new();` to `UserConfiguration`
    - Existing `JournalExpiration` in `AutoQacSettings` stays as-is (backward compat); the new RetentionSettings is the Phase 4 replacement for retention control

    **3. Add config helper methods to IConfigurationService**:
    - Add `Task<Dictionary<string, object?>> GetAllSettingsAsync(CancellationToken ct = default)` -- returns a flat dictionary of all user-facing settings (paths, timeouts, toggles) for bulk inspection
    - Add `Task UpdateMultipleAsync(Action<UserConfiguration> updateAction, CancellationToken ct = default)` -- loads config, applies multiple mutations via the action delegate, saves once. This replaces repeated load-mutate-save cycles (CONF-03)
    - Add `void NotifyExternalSaveCompleted(string fileHash)` -- called by ConfigurationService after writing to disk, so the watcher can update its lastKnownHash and skip the next FSW event
    - Add `Task ReloadFromDiskAsync(CancellationToken ct = default)` -- forces a fresh read from disk bypassing cache, used by ConfigWatcherService

    **4. Implement helper methods in ConfigurationService**:
    - `GetAllSettingsAsync`: Load config, return dictionary with keys like "XEditPath", "LoadOrderPath", "Mo2Binary", "Mo2Mode", "CleaningTimeout", "JournalExpiration", "CpuThreshold", "DisableSkipLists", "LogRetention.Mode", "LogRetention.MaxAgeDays", "LogRetention.MaxFileCount"
    - `UpdateMultipleAsync`: Acquire _fileLock, load config, invoke action delegate on it, save via SaveUserConfigAsync (which emits immediately + debounces to disk)
    - `ReloadFromDiskAsync`: Clear _pendingConfig and _mainConfigCache (for MainConfig reload too), read from disk under _fileLock, update _lastKnownGoodConfig, emit via _configChanges
    - After `SaveToDiskWithRetryAsync` succeeds, compute SHA256 of the written file and store as `_lastWrittenHash`. Expose a method `GetLastWrittenHash()` returning this value so ConfigWatcherService can compare.
    - NOTE: Use `System.Security.Cryptography.SHA256.HashData(stream)` with `Convert.ToHexString()` per research recommendation (Claude's discretion on hash algorithm: SHA256)

    **5. Create IConfigWatcherService** (`AutoQAC/Services/Configuration/IConfigWatcherService.cs`):
    - Interface with:
      - `void StartWatching()` -- begins FSW monitoring
      - `void StopWatching()` -- stops FSW monitoring
      - `IDisposable` for cleanup

    **6. Create ConfigWatcherService** (`AutoQAC/Services/Configuration/ConfigWatcherService.cs`):
    - Constructor: inject `IConfigurationService`, `IStateService`, `ILoggingService`, config directory path
    - Create `FileSystemWatcher` watching the config directory for `AutoQAC Settings.yaml` changes (NotifyFilter: LastWrite | Size)
    - Pipe FSW Changed events through `Observable.FromEventPattern` -> `Throttle(500ms)` -> `ObserveOn(TaskpoolScheduler)` -> subscriber
    - In subscriber:
      1. Compute SHA256 of the file on disk
      2. Compare to `_configService.GetLastWrittenHash()` -- if match, skip (this is our own save, not external)
      3. Compare to `_lastKnownExternalHash` -- if match, skip (no actual change despite FSW event)
      4. If IsCleaning (check `_stateService.CurrentState.IsCleaning`), set `_hasDeferredChanges = true` and store hash, log warning, return
      5. Otherwise: attempt to deserialize the file content. If deserialization fails (invalid YAML), log warning "Invalid external config edit rejected, keeping previous config", do NOT reload
      6. If valid: call `_configService.ReloadFromDiskAsync()`, update `_lastKnownExternalHash`
    - Subscribe to `_stateService.StateChanged.Select(s => s.IsCleaning).DistinctUntilChanged().Where(cleaning => !cleaning && _hasDeferredChanges)` to apply deferred changes when cleaning ends
    - Implement IDisposable: dispose FSW, dispose Rx subscriptions

    **7. Register services in DI** (`AutoQAC/Infrastructure/ServiceCollectionExtensions.cs`):
    - Add `services.AddSingleton<IConfigWatcherService, ConfigWatcherService>()` in `AddConfiguration` method
    - The watcher will be started from App.axaml.cs after service provider is built

    CRITICAL PITFALLS TO AVOID (from research):
    - FSW fires multiple events for a single save: the hash comparison gate handles this
    - Race between debounced save and watcher: ConfigurationService updates _lastWrittenHash after save, watcher checks it before reloading
    - ConfigWatcherService must validate YAML before reloading: invalid external edits are rejected (user decision: "keep previous known-good config, log a warning")
    - Config changes during cleaning are deferred until session ends (user decision)
    - Use content hashing not file timestamps (user decision)
  </action>
  <verify>
    `dotnet build` succeeds with no errors. Verify new files exist:
    - `AutoQAC/Models/Configuration/RetentionSettings.cs`
    - `AutoQAC/Services/Configuration/IConfigWatcherService.cs`
    - `AutoQAC/Services/Configuration/ConfigWatcherService.cs`
    Verify IConfigurationService has new methods: `GetAllSettingsAsync`, `UpdateMultipleAsync`, `ReloadFromDiskAsync`.
    Verify ConfigurationService computes SHA256 hash after save.
  </verify>
  <done>
    RetentionSettings model with AgeBased/CountBased modes exists. UserConfiguration has LogRetention property. IConfigurationService has batch helper methods. ConfigWatcherService watches for YAML changes using FSW + SHA256 hash gating, defers during cleaning, rejects invalid edits. All registered in DI. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Legacy migration service rewrite and migration banner wiring</name>
  <files>
    AutoQAC/Services/Configuration/ILegacyMigrationService.cs
    AutoQAC/Services/Configuration/LegacyMigrationService.cs
    AutoQAC/Services/Configuration/ConfigurationService.cs
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
    AutoQAC/App.axaml.cs
    AutoQAC/ViewModels/MainWindowViewModel.cs
  </files>
  <action>
    **1. Create ILegacyMigrationService** (`AutoQAC/Services/Configuration/ILegacyMigrationService.cs`):
    - Interface with:
      - `Task<MigrationResult> MigrateIfNeededAsync(CancellationToken ct = default)`
    - Create `MigrationResult` record in the same file (or as a nested type):
      - `bool Attempted` -- whether legacy files were found
      - `bool Success` -- whether migration completed without errors
      - `string? WarningMessage` -- null if success or not attempted; details on failure
      - `List<string> MigratedFiles` -- which files were migrated
      - `List<string> FailedFiles` -- which files failed

    **2. Create LegacyMigrationService** (`AutoQAC/Services/Configuration/LegacyMigrationService.cs`):
    - Constructor: inject `ILoggingService`, config directory path (same pattern as ConfigurationService)
    - Create private YamlDotNet serializer/deserializer (same config as ConfigurationService: NullNamingConvention, IgnoreUnmatchedProperties)
    - `MigrateIfNeededAsync` flow:
      1. Check for `AutoQAC Config.yaml` (legacy Python file) in config directory
      2. If not found: return `MigrationResult(Attempted: false, Success: true, ...)`
      3. Check if `AutoQAC Settings.yaml` already exists: if yes, skip migration (user decision: "migration only runs when no C# config exists -- one-time bootstrap, not merge"). Return `MigrationResult(Attempted: false, ...)`
      4. Read legacy file content
      5. Attempt to deserialize as UserConfiguration (with IgnoreUnmatchedProperties for Python-only keys)
      6. If deserialization fails: return MigrationResult with Success=false, WarningMessage explaining the parse error
      7. If valid: serialize to YAML and write to `AutoQAC Settings.yaml`
      8. Create backup directory: `AutoQAC Data/migration_backup/` (per Claude's discretion recommendation)
      9. Copy legacy file to backup: `migration_backup/{timestamp:yyyy-MM-dd}_AutoQAC Config.yaml`
      10. Delete the original legacy file
      11. Return MigrationResult(Attempted: true, Success: true, MigratedFiles: ["AutoQAC Config.yaml"])
    - Error handling: if backup or delete fails, do NOT delete the original. Log warning, return partial success with WarningMessage.
    - CRITICAL: backup-then-delete order (fix for CONF-06 bug where deletion happened before backup)

    **3. Remove legacy migration from ConfigurationService**:
    - Delete the `MigrateLegacyConfigAsync` private method from ConfigurationService
    - Remove the `_migrationCompleted` field
    - Remove the migration call from `LoadUserConfigAsync` (the `if (!_migrationCompleted)` block)
    - Migration is now handled by LegacyMigrationService at app startup, before ConfigurationService loads

    **4. Add migration banner state to MainWindowViewModel**:
    - Add properties:
      - `bool HasMigrationWarning` (with RaiseAndSetIfChanged)
      - `string? MigrationWarningMessage` (with RaiseAndSetIfChanged)
    - Add command: `ReactiveCommand<Unit, Unit> DismissMigrationWarningCommand` that sets HasMigrationWarning = false
    - Add public method `void ShowMigrationWarning(string message)` that sets both properties. This is called from App.axaml.cs after migration runs.

    **5. Register and wire in App.axaml.cs**:
    - Register `ILegacyMigrationService` as singleton in `AddConfiguration` (ServiceCollectionExtensions.cs)
    - In `App.OnFrameworkInitializationCompleted`, after building service provider and creating MainWindow:
      1. Resolve `ILegacyMigrationService`
      2. Call `MigrateIfNeededAsync()` (fire-and-forget with error handling)
      3. If result.Attempted && !result.Success: call `viewModel.ShowMigrationWarning(result.WarningMessage)`
    - Also resolve `IConfigWatcherService` and call `StartWatching()` to begin config file monitoring
    - In `desktop.ShutdownRequested`, also dispose/stop the config watcher

    **6. Wire migration to run on EVERY app startup** (user decision: "auto-detect legacy Python config files on every app startup"):
    - The migration service checks for the legacy file each time. Since it only migrates when no C# config exists, subsequent startups will be a no-op (legacy file won't exist after successful migration, or C# config will already exist).

    CRITICAL: Do NOT merge configs. User decision explicitly says "one-time bootstrap, not a merge". If C# config already exists, migration is skipped entirely.
  </action>
  <verify>
    `dotnet build` succeeds. Verify:
    - `AutoQAC/Services/Configuration/ILegacyMigrationService.cs` exists with MigrateIfNeededAsync
    - `AutoQAC/Services/Configuration/LegacyMigrationService.cs` exists with backup-then-delete flow
    - ConfigurationService no longer contains `MigrateLegacyConfigAsync`
    - MainWindowViewModel has `HasMigrationWarning`, `MigrationWarningMessage`, `DismissMigrationWarningCommand`
    - App.axaml.cs resolves and calls migration service on startup
    Run `dotnet test` to verify no regressions in existing tests.
  </verify>
  <done>
    Legacy migration is extracted to dedicated ILegacyMigrationService with proper backup-then-delete order. Migration runs on every app startup but only acts when no C# config exists. Failures produce a MigrationResult that is wired to MainWindowViewModel's warning banner state. ConfigWatcherService is started on app startup. Old migration code removed from ConfigurationService. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` compiles with zero errors and zero warnings (treat warnings as errors)
2. `dotnet test` -- all existing tests pass (no regressions from ConfigurationService migration removal or interface changes)
3. Verify ConfigWatcherService uses SHA256.HashData (not MD5, not file timestamps) -- grep for "SHA256" in ConfigWatcherService.cs
4. Verify LegacyMigrationService performs backup BEFORE delete -- grep for "Copy" appearing before "Delete" in the migration flow
5. Verify no merge logic exists in migration -- grep for "Merge" or merging skip lists in LegacyMigrationService (should find none)
6. Verify ConfigurationService no longer has MigrateLegacyConfigAsync -- grep for "MigrateLegacy" in ConfigurationService.cs (should find none)
</verification>

<success_criteria>
- ConfigWatcherService detects external YAML changes via FSW + SHA256 hash gating
- ConfigWatcherService defers reloads during cleaning sessions
- ConfigWatcherService ignores app-initiated saves (no circular reload)
- ConfigWatcherService rejects invalid external edits
- LegacyMigrationService migrates with backup-then-delete (CONF-06 fix)
- LegacyMigrationService only runs when no C# config exists (bootstrap only)
- Migration warning banner state is wired in MainWindowViewModel
- RetentionSettings model supports AgeBased and CountBased modes
- IConfigurationService has GetAllSettingsAsync, UpdateMultipleAsync, ReloadFromDiskAsync
- All new services registered in DI
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-configuration-enhancement/04-01-SUMMARY.md`
</output>
