---
phase: 02-plugin-pipeline-robustness
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Services/Plugin/IPluginValidationService.cs
  - AutoQAC/Services/Plugin/PluginValidationService.cs
  - AutoQAC/Services/Plugin/PluginLoadingService.cs
  - AutoQAC/Models/PluginInfo.cs
  - AutoQAC.Tests/Services/PluginValidationServiceTests.cs
  - AutoQAC.Tests/Services/PluginLoadingServiceTests.cs
  - AutoQAC.Tests/Services/CleaningOrchestratorTests.cs
autonomous: true

must_haves:
  truths:
    - "Load order files with BOM markers, blank lines, separators, and malformed entries parse correctly without crashing or silently skipping valid plugins"
    - "Plugins loaded from file-based load orders have correct absolute paths built from the game data folder"
    - "ValidatePluginExists checks existence and readability for all plugins uniformly -- no dual code path"
    - "Only .esp, .esm, .esl extensions are accepted as valid plugin entries"
    - "MO2 separator lines (starting with *) are stripped and logged at debug level, not treated as plugins"
  artifacts:
    - path: "AutoQAC/Services/Plugin/IPluginValidationService.cs"
      provides: "Updated interface with dataFolderPath parameter"
      contains: "dataFolderPath"
    - path: "AutoQAC/Services/Plugin/PluginValidationService.cs"
      provides: "Encoding-aware file reading, line validation pipeline, FullPath resolution"
      contains: "StreamReader"
    - path: "AutoQAC/Models/PluginInfo.cs"
      provides: "PluginWarningKind enum and optional validation result on PluginInfo"
    - path: "AutoQAC.Tests/Services/PluginValidationServiceTests.cs"
      provides: "Comprehensive test coverage for parsing edge cases"
      min_lines: 150
  key_links:
    - from: "AutoQAC/Services/Plugin/PluginValidationService.cs"
      to: "AutoQAC/Services/Plugin/IPluginValidationService.cs"
      via: "GetPluginsFromLoadOrderAsync signature with dataFolderPath"
      pattern: "dataFolderPath"
    - from: "AutoQAC/Services/Plugin/PluginLoadingService.cs"
      to: "AutoQAC/Services/Plugin/IPluginValidationService.cs"
      via: "GetPluginsFromFileAsync passes through dataFolderPath"
      pattern: "GetPluginsFromLoadOrderAsync"
---

<objective>
Rewrite the plugin line parsing and FullPath resolution pipeline so that load order files are read with encoding auto-detection, each line is validated through a structured pipeline (trim, skip blanks/comments, strip prefixes, validate extension, reject malformed entries), and plugin FullPath values are resolved to real absolute paths using the game's data folder.

Purpose: PLUG-01 (edge case parsing), PLUG-02 (FullPath placeholder fix), and PLUG-03 (dual code path elimination) are the core path resolution deficiencies that block Phase 5 backup (which needs real file paths to copy plugins).

Output: Robust PluginValidationService with encoding-aware reading, validated parsing, and correct FullPath resolution. All existing tests updated for the new interface signature.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-plugin-pipeline-robustness/02-RESEARCH.md

Key files to read before starting:
@AutoQAC/Services/Plugin/IPluginValidationService.cs
@AutoQAC/Services/Plugin/PluginValidationService.cs
@AutoQAC/Services/Plugin/IPluginLoadingService.cs
@AutoQAC/Services/Plugin/PluginLoadingService.cs
@AutoQAC/Models/PluginInfo.cs
@AutoQAC.Tests/Services/PluginValidationServiceTests.cs
@AutoQAC.Tests/Services/PluginLoadingServiceTests.cs
@AutoQAC.Tests/Services/CleaningOrchestratorTests.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for plugin line validation and FullPath resolution</name>
  <files>
    AutoQAC/Models/PluginInfo.cs
    AutoQAC/Services/Plugin/IPluginValidationService.cs
    AutoQAC.Tests/Services/PluginValidationServiceTests.cs
  </files>
  <action>
**Step 1: Add PluginWarningKind enum and update PluginInfo model**

Add a `PluginWarningKind` enum to `AutoQAC/Models/PluginInfo.cs` (in the same file, above the record):

```csharp
public enum PluginWarningKind { None, NotFound, Unreadable, ZeroByte, MalformedEntry, InvalidExtension }
```

Add an optional property to `PluginInfo`:
```csharp
public PluginWarningKind Warning { get; init; } = PluginWarningKind.None;
```

**Step 2: Update IPluginValidationService interface**

Change the `GetPluginsFromLoadOrderAsync` signature to accept an optional `dataFolderPath` parameter:

```csharp
Task<List<PluginInfo>> GetPluginsFromLoadOrderAsync(
    string loadOrderPath,
    string? dataFolderPath = null,
    CancellationToken ct = default);
```

Change `ValidatePluginExists` to also check readability (not just existence):
```csharp
PluginWarningKind ValidatePluginFile(PluginInfo plugin);
```

**Step 3: Write comprehensive failing tests**

Create test cases in `PluginValidationServiceTests.cs` covering:

1. **BOM handling**: Write a temp file with UTF-8 BOM (`\xEF\xBB\xBF`) prefix + "Skyrim.esm\n". First plugin FileName must be "Skyrim.esm" (no BOM bytes).

2. **Blank lines and whitespace**: Content with `\n\n  \n*Skyrim.esm\n\nUpdate.esm\n  \n`. Should parse to exactly 2 plugins.

3. **Comment lines**: Content with `# comment\n  # indented comment\nSkyrim.esm`. Should parse to 1 plugin.

4. **MO2 separator lines**: Content with `*Skyrim.esm\n*_separator_\n+SomeSep\n-DisabledMod\nUpdate.esm`. After stripping prefix `*`, `_separator_` has no valid extension -- it should be skipped. `+SomeSep` and `-DisabledMod` also lack valid extensions -- skipped. Result: 2 plugins (Skyrim.esm, Update.esm).

5. **Invalid extensions**: Content with `Skyrim.esm\nreadme.txt\nnotes.md\nMod.esp`. Should parse to 2 valid plugins, skip the .txt and .md entries.

6. **Path separators in entry (malformed)**: Content with `Skyrim.esm\nC:\\Data\\Mod.esp\nUpdate.esm`. The entry with backslash should be skipped as malformed. Result: 2 plugins.

7. **Control characters**: Content with `Skyrim.esm\n\x00BadPlugin.esp\nUpdate.esm`. Line with null byte should be skipped.

8. **FullPath resolution with dataFolderPath**: Call with `dataFolderPath = "C:\\Games\\SkyrimSE\\Data"`. Plugin "Skyrim.esm" should have FullPath = `"C:\\Games\\SkyrimSE\\Data\\Skyrim.esm"`.

9. **FullPath without dataFolderPath**: Call without dataFolderPath. Plugin FullPath should still equal FileName (backward compat, but now explicitly documented).

10. **Empty/missing file**: Empty path returns empty list. Missing file returns empty list (not crash).

11. **ValidatePluginFile**: Test with a real temp file (returns None), missing file (returns NotFound), zero-byte file (returns ZeroByte).

12. **UTF-16 LE BOM file**: Write a temp file with UTF-16 LE encoding. Plugins should parse correctly.

These tests should FAIL initially because the implementation hasn't been updated yet.

Run `dotnet test` and confirm the new tests fail (compilation errors count as failures for TDD purposes).
  </action>
  <verify>
    `dotnet test --filter "PluginValidationServiceTests"` shows compilation errors or test failures for the new tests. Existing tests that reference the old interface signature also fail.
  </verify>
  <done>
    New test file compiles (after minimal stub changes to make it compile), and all new tests are RED (failing). The test suite captures all edge cases from PLUG-01, PLUG-02, PLUG-03.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement encoding-aware parsing, line validation pipeline, and FullPath resolution</name>
  <files>
    AutoQAC/Services/Plugin/PluginValidationService.cs
    AutoQAC/Services/Plugin/PluginLoadingService.cs
    AutoQAC.Tests/Services/PluginLoadingServiceTests.cs
    AutoQAC.Tests/Services/CleaningOrchestratorTests.cs
  </files>
  <action>
**Step 1: Rewrite PluginValidationService.GetPluginsFromLoadOrderAsync**

Replace `File.ReadAllLinesAsync` with `StreamReader`-based reading that auto-detects BOM:

```csharp
private static async Task<string[]> ReadLinesWithEncodingDetectionAsync(
    string path, CancellationToken ct)
{
    // StreamReader with detectEncodingFromByteOrderMarks: true handles UTF-8 BOM,
    // UTF-16 LE/BE BOM, and UTF-32 BOM automatically. Falls back to UTF-8 by default.
    using var reader = new StreamReader(path, detectEncodingFromByteOrderMarks: true);
    var content = await reader.ReadToEndAsync(ct).ConfigureAwait(false);
    return content.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
}
```

Add the `dataFolderPath` parameter to the method. Implement line validation pipeline:

```csharp
private static readonly HashSet<string> ValidExtensions = new(StringComparer.OrdinalIgnoreCase)
    { ".esp", ".esm", ".esl" };
private static readonly HashSet<char> PrefixChars = new() { '*', '+', '-' };
```

For each line:
1. Skip blank/whitespace lines
2. Skip comment lines (starts with `#` after trim)
3. Strip leading prefix characters (`*`, `+`, `-`) then re-trim
4. If empty after stripping, skip (debug log "separator line stripped")
5. Check for path separators (`/`, `\`, `\0`) -- warn and skip as malformed
6. Check for control characters (any char < 0x20 except whitespace) -- warn and skip
7. Validate extension against `ValidExtensions` -- warn and skip if invalid
8. Build PluginInfo with:
   - `FileName = validatedName`
   - `FullPath = dataFolderPath != null ? Path.Combine(dataFolderPath, validatedName) : validatedName`
   - `Warning = PluginWarningKind.None`

For missing/empty load order file path: return empty list with a warning log. Per user decision, this is a hard error at the orchestrator level (handled in Plan 02-02), but the validation service just returns empty.

**Step 2: Rewrite ValidatePluginFile (replacing ValidatePluginExists)**

Eliminate the dual code path. The new method always checks the full path:

```csharp
public PluginWarningKind ValidatePluginFile(PluginInfo plugin)
{
    if (string.IsNullOrEmpty(plugin.FullPath) || !Path.IsPathRooted(plugin.FullPath))
        return PluginWarningKind.NotFound; // Can't validate relative paths

    if (!File.Exists(plugin.FullPath))
        return PluginWarningKind.NotFound;

    try
    {
        var info = new FileInfo(plugin.FullPath);
        if (info.Length == 0)
            return PluginWarningKind.ZeroByte;

        // Try opening briefly to verify readability (not locked)
        using var stream = File.Open(plugin.FullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        return PluginWarningKind.None;
    }
    catch (UnauthorizedAccessException)
    {
        return PluginWarningKind.Unreadable;
    }
    catch (IOException)
    {
        return PluginWarningKind.Unreadable;
    }
}
```

**Step 3: Update PluginLoadingService.GetPluginsFromFileAsync**

The method currently delegates to `_pluginValidation.GetPluginsFromLoadOrderAsync(loadOrderPath, ct)`. It does NOT pass `dataFolderPath`. This is correct for the file-based fallback path (caller should provide dataFolderPath if needed). However, update the `IPluginLoadingService.GetPluginsFromFileAsync` signature to accept an optional `dataFolderPath` and pass it through:

```csharp
public async Task<List<PluginInfo>> GetPluginsFromFileAsync(
    string loadOrderPath,
    string? dataFolderPath = null,
    CancellationToken ct = default)
{
    return await _pluginValidation.GetPluginsFromLoadOrderAsync(loadOrderPath, dataFolderPath, ct)
        .ConfigureAwait(false);
}
```

Update the `IPluginLoadingService` interface to match.

**Step 4: Update ALL mock setups across the test suite**

CRITICAL (Moq pitfall from MEMORY.md): Adding `dataFolderPath` parameter to `GetPluginsFromLoadOrderAsync` breaks ALL existing Moq `Setup` and `Verify` calls. Grep the ENTIRE test project for `GetPluginsFromLoadOrderAsync` and update every match:

- `PluginLoadingServiceTests.cs`: The mock setup `s.GetPluginsFromLoadOrderAsync(loadOrderPath, default)` must become `s.GetPluginsFromLoadOrderAsync(loadOrderPath, It.IsAny<string?>(), default)`.
- `CleaningOrchestratorTests.cs`: Same pattern -- search for all references.
- Any other test file referencing this method.

Also grep for `ValidatePluginExists` and update to `ValidatePluginFile` (returns `PluginWarningKind` instead of `bool`).

Also grep for `GetPluginsFromFileAsync` and update mocks if `dataFolderPath` parameter was added.

**Step 5: Run all tests**

Run `dotnet test` and verify:
- All new tests from Task 1 pass (GREEN)
- All existing tests pass (no regressions from interface changes)

If any tests fail, fix them before proceeding.
  </action>
  <verify>
    `dotnet test` passes with 0 failures. All new edge case tests are GREEN. All previously-existing tests still pass.
  </verify>
  <done>
    PluginValidationService reads files with BOM auto-detection, validates each line through the pipeline (blanks, comments, prefixes, extension, malformed), resolves FullPath using dataFolderPath, and ValidatePluginFile checks existence + readability uniformly. No dual code path remains. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds with no warnings related to changed files
2. `dotnet test` passes all tests (new and existing)
3. Verify no test file still references `ValidatePluginExists` (old method name)
4. Verify no test file has `GetPluginsFromLoadOrderAsync` mock setup with only 2 parameters (old signature)
5. Manual inspection: PluginValidationService no longer uses `File.ReadAllLinesAsync` (uses StreamReader)
6. Manual inspection: `ValidatePluginFile` has NO `if (Path.IsPathRooted(...))` branching that returns `true` for non-rooted paths
</verification>

<success_criteria>
- Load order files with UTF-8 BOM, UTF-16 LE BOM, blank lines, comments, MO2 separators, invalid extensions, path separators, and control characters all parse correctly
- PluginInfo.FullPath is an absolute path when dataFolderPath is provided
- ValidatePluginFile returns specific PluginWarningKind values (not just bool)
- Zero regressions in existing test suite
- No dual code path in ValidatePluginExists/ValidatePluginFile
</success_criteria>

<output>
After completion, create `.planning/phases/02-plugin-pipeline-robustness/02-01-SUMMARY.md`
</output>
