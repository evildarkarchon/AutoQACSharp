---
phase: 01-foundation-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Services/Process/IProcessExecutionService.cs
  - AutoQAC/Services/Process/ProcessExecutionService.cs
  - AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/Models/TerminationResult.cs
  - AutoQAC/Models/TrackedProcess.cs
autonomous: true

must_haves:
  truths:
    - "Clicking Stop during cleaning sends a graceful close to xEdit, waits a 2.5s grace period, then reports GracePeriodExpired if still running"
    - "Clicking Stop a second time (or calling ForceStopCleaning) immediately kills the entire xEdit process tree via Process.Kill(entireProcessTree: true)"
    - "On startup and before each cleaning run, orphaned xEdit processes we previously launched are detected via PID file and killed silently"
    - "StopCleaning never throws ObjectDisposedException even when called concurrently with CTS disposal"
    - "Process.WaitForExitAsync is used instead of the Exited event (workaround for .NET bug with Kill(true))"
    - "After cancellation, partial results (which plugins completed) are preserved in the session result"
  artifacts:
    - path: "AutoQAC/Models/TerminationResult.cs"
      provides: "Enum distinguishing graceful exit, force killed, grace period expired, already exited"
    - path: "AutoQAC/Models/TrackedProcess.cs"
      provides: "Record for PID file entries (Pid, StartTime, PluginName)"
    - path: "AutoQAC/Services/Process/ProcessExecutionService.cs"
      provides: "Hardened process termination with escalation, PID tracking, orphan cleanup"
    - path: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      provides: "Async StopCleaning with escalation, race-safe CTS, partial result preservation"
  key_links:
    - from: "CleaningOrchestrator.StopCleaningAsync"
      to: "ProcessExecutionService.TerminateProcessAsync"
      via: "Escalating stop: graceful -> force kill"
      pattern: "TerminateProcessAsync.*forceKill"
    - from: "ProcessExecutionService.ExecuteAsync"
      to: "PID file tracking"
      via: "Write PID before process start, remove after exit"
      pattern: "TrackProcessAsync|UntrackProcessAsync"
    - from: "App startup / CleaningOrchestrator"
      to: "ProcessExecutionService.CleanOrphanedProcessesAsync"
      via: "Called on startup and before each cleaning run"
      pattern: "CleanOrphanedProcessesAsync"
---

<objective>
Harden process termination so that stopping a cleaning run guarantees xEdit is dead before the UI reports "cancelled", orphaned processes from crashes are cleaned up silently, and the CancellationTokenSource race condition is fixed.

Purpose: The current process termination uses a fixed 2-second wait with `process.Kill()` (single process, not tree), relies on the `Exited` event via TCS (which has a known .NET bug when `Kill(true)` is used), and `StopCleaning()` has a race condition on the CancellationTokenSource. This plan replaces all of that with a robust escalation pattern, PID-tracked orphan cleanup, and race-safe cancellation.

Output: Modified ProcessExecutionService with escalating termination + PID tracking, modified CleaningOrchestrator with async stop + CTS race fix, new TerminationResult enum and TrackedProcess model.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hardening/01-CONTEXT.md
@.planning/phases/01-foundation-hardening/01-RESEARCH.md
@AutoQAC/Services/Process/IProcessExecutionService.cs
@AutoQAC/Services/Process/ProcessExecutionService.cs
@AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningService.cs
@AutoQAC/Models/AppState.cs
@AutoQAC/Models/CleaningResult.cs
@AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TerminationResult enum, TrackedProcess model, and harden ProcessExecutionService</name>
  <files>
    AutoQAC/Models/TerminationResult.cs
    AutoQAC/Models/TrackedProcess.cs
    AutoQAC/Services/Process/IProcessExecutionService.cs
    AutoQAC/Services/Process/ProcessExecutionService.cs
  </files>
  <action>
**1. Create `AutoQAC/Models/TerminationResult.cs`:**
```csharp
namespace AutoQAC.Models;

public enum TerminationResult
{
    AlreadyExited,
    GracefulExit,
    GracePeriodExpired,
    ForceKilled
}
```

**2. Create `AutoQAC/Models/TrackedProcess.cs`:**
A record for PID file entries stored in `AutoQAC Data/autoqac-pids.json`:
```csharp
namespace AutoQAC.Models;

public sealed record TrackedProcess
{
    public int Pid { get; init; }
    public DateTime StartTime { get; init; }
    public string PluginName { get; init; } = string.Empty;
}
```

**3. Update `IProcessExecutionService` interface:**
Add these new members to the interface:
- `Task<TerminationResult> TerminateProcessAsync(Process process, bool forceKill = false, CancellationToken ct = default)` -- Escalating termination (graceful with 2.5s grace, or immediate force kill)
- `Task CleanOrphanedProcessesAsync(CancellationToken ct = default)` -- Detect and kill orphaned xEdit processes from PID file
- `Task TrackProcessAsync(Process process, string pluginName, CancellationToken ct = default)` -- Write PID entry to tracking file
- `Task UntrackProcessAsync(int pid, CancellationToken ct = default)` -- Remove PID entry from tracking file
- Add `TerminationResult` to the using statements / make it accessible

Keep all existing members unchanged.

**4. Rewrite `ProcessExecutionService`:**

Replace the existing `TerminateProcessGracefullyAsync` with the new `TerminateProcessAsync` method implementing the escalation pattern from RESEARCH.md Pattern 1:

- **Graceful path (forceKill=false):** Call `process.CloseMainWindow()`. Check the return value -- if it returns `false` (expected with `CreateNoWindow=true`), skip the grace period and return `GracePeriodExpired` immediately (caller should escalate). If it returns `true`, wait up to 2500ms using `process.WaitForExitAsync()` with a linked CancellationTokenSource. If the process exits within the grace period, return `GracefulExit`. If the grace period expires, return `GracePeriodExpired`.
- **Force path (forceKill=true):** Call `process.Kill(entireProcessTree: true)` then `await process.WaitForExitAsync(ct)`. Return `ForceKilled`. Catch `InvalidOperationException` (process already exited) and return `AlreadyExited`. Catch `System.ComponentModel.Win32Exception` and log error.
- If `process.HasExited` is already true at the start, return `AlreadyExited`.

Replace the TCS-based wait in `ExecuteAsync` with `process.WaitForExitAsync()`:
- Remove the `TaskCompletionSource<bool>` pattern entirely
- Remove `process.Exited += (s, e) => tcs.TrySetResult(true)` and `process.EnableRaisingEvents = true`
- Instead, after `process.Start()` and `BeginOutputReadLine()`/`BeginErrorReadLine()`, await `process.WaitForExitAsync(linkedToken)` directly
- On `OperationCanceledException`: determine if timeout or user cancel, then call `TerminateProcessAsync(process, forceKill: false, ct)` for the initial attempt (graceful). If the result is `GracePeriodExpired`, call `TerminateProcessAsync(process, forceKill: true, ct)` to force-kill.

Add PID tracking methods:
- **`TrackProcessAsync`:** Read existing JSON array from `autoqac-pids.json` in the config directory (resolve using the same pattern as ConfigurationService -- `AutoQAC Data/` relative to base directory, or in debug mode search parent dirs). Add new entry `{ Pid, StartTime = process.StartTime, PluginName }`. Write back. Use `System.Text.Json.JsonSerializer` (built-in). If file doesn't exist, create it.
- **`UntrackProcessAsync`:** Read file, remove entry matching `pid`, write back. If file doesn't exist or is empty, no-op.
- **`CleanOrphanedProcessesAsync`:** Read PID file. For each entry, try `Process.GetProcessById(entry.Pid)`. Verify it is actually xEdit by checking: (a) process name contains known xEdit patterns (SSEEdit, FO4Edit, FO3Edit, FNVEdit, TES5VREdit, xEdit -- case-insensitive), AND (b) `process.StartTime` is within 5 seconds of tracked start time. If both match, call `process.Kill(entireProcessTree: true)` followed by `process.WaitForExitAsync()`. Log each action with `[Orphan]` prefix. After processing all entries, clear the PID file. Catch `ArgumentException` (process no longer exists) and `InvalidOperationException` (access denied) gracefully.

Wire PID tracking into `ExecuteAsync`:
- After `process.Start()`, call `await TrackProcessAsync(process, startInfo.Arguments, ct)` (use arguments as plugin name proxy, or accept pluginName as an additional optional parameter on ExecuteAsync -- prefer adding it as optional parameter: `string? pluginName = null`).
- In the finally block (or after `WaitForExitAsync` completes), call `await UntrackProcessAsync(process.Id, ct)`.

Add a `AcquireProcessSlotAsync` timeout per PROC-06:
- Add a 60-second timeout to `_processSlots.WaitAsync()` as a safety net. If it times out, log a warning: "[Termination] Semaphore slot acquisition timed out after 60s -- possible deadlock". Throw `TimeoutException`.
- Also log a warning at 10 seconds using a `Task.Delay(10000)` race: `var acquired = await Task.WhenAny(slotTask, Task.Delay(10000, ct))`. If the delay wins, log warning but continue waiting.

**IMPORTANT: Do not rely on Process.Exited event anywhere.** Use WaitForExitAsync exclusively. This is a known .NET bug with Kill(entireProcessTree: true).

**IMPORTANT: Use structured Serilog logging** with the prefix patterns from RESEARCH.md:
- `[Orphan]` for orphan detection/cleanup
- `[Termination]` for process termination actions
  </action>
  <verify>
Run `dotnet build` -- project must compile without errors. Check that `TerminateProcessAsync` exists with both graceful and force paths. Check that `CleanOrphanedProcessesAsync` reads PID file and validates process name + start time. Check that the old TCS pattern is fully removed from `ExecuteAsync`. Check that `AcquireProcessSlotAsync` has a timeout safety net.
  </verify>
  <done>
ProcessExecutionService uses `Process.Kill(entireProcessTree: true)` for force kill, `Process.WaitForExitAsync()` instead of the Exited event TCS, tracks PIDs to a JSON file, and cleans orphans on demand. The slot acquisition has a 60-second timeout safety net. No compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix CTS race in CleaningOrchestrator and add async stop with escalation</name>
  <files>
    AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  </files>
  <action>
**1. Update `ICleaningOrchestrator`:**
- Change `void StopCleaning()` to `Task StopCleaningAsync()` -- must be async because it calls `TerminateProcessAsync` which is async.
- Add `Task ForceStopCleaningAsync()` -- immediate force kill, no grace period.

**2. Fix the CTS race condition in CleaningOrchestrator (PROC-04):**

Replace the current `StopCleaning()` implementation with the safe pattern from RESEARCH.md Pattern 5:
```csharp
public async Task StopCleaningAsync()
{
    _logger.Information("[Termination] Graceful stop requested");
    CancellationTokenSource? cts;
    lock (_ctsLock)
    {
        cts = _cleaningCts;
    }
    try
    {
        cts?.Cancel();
    }
    catch (ObjectDisposedException)
    {
        _logger.Debug("[Termination] CTS already disposed -- cleaning likely already finished");
    }
}
```

Add `ForceStopCleaningAsync`:
```csharp
public async Task ForceStopCleaningAsync()
{
    _logger.Information("[Termination] Force stop requested");
    CancellationTokenSource? cts;
    lock (_ctsLock)
    {
        cts = _cleaningCts;
    }
    try
    {
        cts?.Cancel();
    }
    catch (ObjectDisposedException)
    {
        _logger.Debug("[Termination] CTS already disposed during force stop");
    }
    // The actual force kill happens in ProcessExecutionService when the CancellationToken
    // triggers the termination path with forceKill=true.
    // We signal force intent by setting a flag that ProcessExecutionService can read.
}
```

Actually, the escalation model needs a way for the orchestrator to distinguish between "first stop" (graceful) and "second stop" (force). Implement this with an `_isStopRequested` flag:
- `private volatile bool _isStopRequested;` -- set to true on first StopCleaningAsync call
- `StopCleaningAsync()`: If `_isStopRequested` is already true (second click), this becomes a force stop. Otherwise, set `_isStopRequested = true` and cancel the CTS (graceful).
- `ForceStopCleaningAsync()`: Always force kills immediately. Cancels CTS if not already cancelled.
- Reset `_isStopRequested = false` at the start of `StartCleaningAsync` and in the finally block.

**3. Add orphan cleanup call before cleaning:**

At the beginning of `StartCleaningAsync` (before validation), call:
```csharp
await _processService.CleanOrphanedProcessesAsync(ct).ConfigureAwait(false);
```
This requires adding `IProcessExecutionService` as a constructor dependency. Add it to the constructor alongside the existing services.

**4. Preserve partial results on cancellation:**

The current code already builds `pluginResults` as it goes and creates a `CleaningSessionResult` in the catch block. Verify that `WasCancelled = true` is set correctly when the loop breaks due to cancellation. The current `wasCancelled = true` in the loop break is correct. Ensure the catch block for `OperationCanceledException` also sets `wasCancelled = true` and creates a session result. Currently the generic `catch (Exception ex)` handles this, but add a specific `catch (OperationCanceledException)` block before it that sets `wasCancelled = true` without rethrowing, and creates the session result. This way cancelled operations don't bubble up as errors.

**5. Register IProcessExecutionService in constructor:**

Add `IProcessExecutionService processService` to the constructor parameters and store as `_processService`. Update the DI registration -- IProcessExecutionService is already registered as singleton in `ServiceCollectionExtensions.AddBusinessLogic()`, so no DI changes needed, just the constructor parameter.

**IMPORTANT**: Keep the `_ctsLock` as `object` (not `Lock`) since the research notes say the current `Lock` is fine for StateService but CleaningOrchestrator already uses `object`. Actually, check the current code -- it uses `private readonly object _ctsLock = new();`. Keep this as-is for the lock pattern.
  </action>
  <verify>
Run `dotnet build` -- project must compile. Verify `StopCleaningAsync` captures CTS reference inside lock and calls Cancel outside. Verify `_isStopRequested` flag enables escalating stop (first click graceful, second click force). Verify `CleanOrphanedProcessesAsync` is called at the start of `StartCleaningAsync`. Verify `OperationCanceledException` is caught separately and creates a session result with `WasCancelled = true`. Run `dotnet test` -- existing tests must pass (may need updates for the interface change from `void StopCleaning()` to `Task StopCleaningAsync()`).
  </verify>
  <done>
CleaningOrchestrator has race-safe CTS handling, escalating stop (graceful -> force), orphan cleanup before cleaning, and proper OperationCanceledException handling with partial result preservation. All existing tests pass after updating for the async StopCleaning interface change.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update callers and fix tests for interface changes</name>
  <files>
    AutoQAC/ViewModels/MainWindowViewModel.cs
    AutoQAC/Views/MainWindow.axaml.cs
    AutoQAC.Tests/Services/CleaningOrchestratorTests.cs
  </files>
  <action>
**1. Update MainWindowViewModel:**

Find where `StopCleaning()` is called (likely in a stop command). Change from:
```csharp
_orchestrator.StopCleaning();
```
to:
```csharp
await _orchestrator.StopCleaningAsync();
```

If the stop command is currently synchronous (e.g., `ReactiveCommand.Create(() => _orchestrator.StopCleaning())`), change it to async: `ReactiveCommand.CreateFromTask(() => _orchestrator.StopCleaningAsync())`.

Also update any reference to `ForceStopCleaningAsync` if applicable. The escalating stop button logic (first click graceful, second click force) should be handled in the ViewModel:
- Track whether a stop has already been requested: `private bool _stopRequested;`
- On stop command: if `_stopRequested` is false, call `StopCleaningAsync()` and set `_stopRequested = true`. If `_stopRequested` is true (second click), call `ForceStopCleaningAsync()`.
- Reset `_stopRequested = false` when cleaning starts and when cleaning finishes.

NOTE: Do NOT implement the full "Stopping..." UI blocking spinner in this plan -- that is a UX concern that will be handled in Plan 01-02 or a future phase. Just wire the escalating stop logic.

**2. Update MainWindow.axaml.cs if needed:**

If there are interaction handlers that call `StopCleaning()`, update them to use the async version.

**3. Update CleaningOrchestratorTests:**

The interface change from `void StopCleaning()` to `Task StopCleaningAsync()` will break existing test mocks. Update:
- Any `mock.Setup(x => x.StopCleaning())` to `mock.Setup(x => x.StopCleaningAsync()).Returns(Task.CompletedTask)`
- Any direct calls to `orchestrator.StopCleaning()` to `await orchestrator.StopCleaningAsync()`
- Add the new `IProcessExecutionService` mock to the CleaningOrchestrator constructor in tests

Run `dotnet test` to verify all tests pass.

**IMPORTANT**: The OperationCanceledException handling change in CleaningOrchestrator may affect test expectations. Review tests that verify cancellation behavior and update assertions if needed.
  </action>
  <verify>
Run `dotnet build` -- project must compile without errors. Run `dotnet test` -- all tests must pass. Verify that the stop command in MainWindowViewModel uses the escalating pattern (first click = graceful, second click = force).
  </verify>
  <done>
All callers updated for async StopCleaning. Tests pass. The stop command implements escalating stop (first click graceful, second click force). The project builds and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds with zero errors and zero warnings related to the changed files
2. `dotnet test` passes all existing tests (with necessary updates for interface changes)
3. ProcessExecutionService no longer uses the `Exited` event or `TaskCompletionSource` pattern
4. ProcessExecutionService uses `Process.Kill(entireProcessTree: true)` for force termination
5. ProcessExecutionService tracks PIDs to `autoqac-pids.json` and cleans orphans
6. CleaningOrchestrator `StopCleaningAsync` captures CTS reference inside lock, calls Cancel outside
7. Escalating stop works: first call = graceful, second call = force kill
8. OperationCanceledException is caught separately and preserves partial results
9. No ObjectDisposedException is possible from the CTS race
</verification>

<success_criteria>
- Process termination uses the escalation pattern: graceful close -> grace period -> force kill tree
- PID file tracking enables orphan cleanup on startup and before cleaning runs
- CancellationTokenSource race condition between StopCleaning and Dispose is eliminated
- Partial cleaning results are preserved when user cancels mid-session
- All existing tests pass after updates for the interface changes
- Semaphore slot acquisition has a 60-second timeout safety net
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hardening/01-01-SUMMARY.md`
</output>
