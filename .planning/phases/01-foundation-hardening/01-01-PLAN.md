---
phase: 01-foundation-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Services/Process/IProcessExecutionService.cs
  - AutoQAC/Services/Process/ProcessExecutionService.cs
  - AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/Models/TerminationResult.cs
  - AutoQAC/Models/TrackedProcess.cs
  - AutoQAC/ViewModels/MainWindowViewModel.cs
  - AutoQAC/Views/MainWindow.axaml.cs
autonomous: true

must_haves:
  truths:
    - "Clicking Stop during cleaning sends a graceful close to xEdit, waits a 2.5s grace period, then reports GracePeriodExpired if still running"
    - "If the grace period expires naturally (user waits patiently), the orchestrator prompts the user 'xEdit didn't stop gracefully. Force kill?' before escalating"
    - "If the user clicks Stop a second time DURING the grace period, the process tree is force-killed immediately with no prompt"
    - "Calling ForceStopCleaningAsync always kills the entire xEdit process tree via Process.Kill(entireProcessTree: true) immediately"
    - "On startup and before each cleaning run, orphaned xEdit processes we previously launched are detected via PID file and killed silently"
    - "StopCleaning never throws ObjectDisposedException even when called concurrently with CTS disposal"
    - "Process.WaitForExitAsync is used instead of the Exited event (workaround for .NET bug with Kill(true))"
    - "After cancellation, partial results (which plugins completed) are preserved in the session result"
    - "Starting a new cleaning session after cancelling a previous one never fails due to leftover process state or locked files"
  artifacts:
    - path: "AutoQAC/Models/TerminationResult.cs"
      provides: "Enum distinguishing graceful exit, force killed, grace period expired, already exited"
    - path: "AutoQAC/Models/TrackedProcess.cs"
      provides: "Record for PID file entries (Pid, StartTime, PluginName)"
    - path: "AutoQAC/Services/Process/ProcessExecutionService.cs"
      provides: "Hardened process termination with escalation, PID tracking, orphan cleanup"
    - path: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      provides: "Async StopCleaning with dual-path escalation, race-safe CTS, partial result preservation"
  key_links:
    - from: "CleaningOrchestrator.StopCleaningAsync"
      to: "ProcessExecutionService.TerminateProcessAsync"
      via: "Orchestrator holds _currentProcess reference, calls TerminateProcessAsync(process, forceKill) directly"
      pattern: "TerminateProcessAsync.*_currentProcess"
    - from: "ProcessExecutionService.ExecuteAsync"
      to: "PID file tracking"
      via: "Write PID before process start, remove after exit"
      pattern: "TrackProcessAsync|UntrackProcessAsync"
    - from: "App startup / CleaningOrchestrator"
      to: "ProcessExecutionService.CleanOrphanedProcessesAsync"
      via: "Called on startup and before each cleaning run"
      pattern: "CleanOrphanedProcessesAsync"
---

<objective>
Harden process termination so that stopping a cleaning run guarantees xEdit is dead before the UI reports "cancelled", orphaned processes from crashes are cleaned up silently, and the CancellationTokenSource race condition is fixed.

Purpose: The current process termination uses a fixed 2-second wait with `process.Kill()` (single process, not tree), relies on the `Exited` event via TCS (which has a known .NET bug when `Kill(true)` is used), and `StopCleaning()` has a race condition on the CancellationTokenSource. This plan replaces all of that with a robust escalation pattern, PID-tracked orphan cleanup, and race-safe cancellation.

Output: Modified ProcessExecutionService with escalating termination + PID tracking, modified CleaningOrchestrator with async stop + CTS race fix, new TerminationResult enum and TrackedProcess model. All callers and tests updated.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hardening/01-CONTEXT.md
@.planning/phases/01-foundation-hardening/01-RESEARCH.md
@AutoQAC/Services/Process/IProcessExecutionService.cs
@AutoQAC/Services/Process/ProcessExecutionService.cs
@AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningService.cs
@AutoQAC/Models/AppState.cs
@AutoQAC/Models/CleaningResult.cs
@AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Add TerminationResult enum, TrackedProcess model, and harden TerminateProcessAsync</name>
  <files>
    AutoQAC/Models/TerminationResult.cs
    AutoQAC/Models/TrackedProcess.cs
    AutoQAC/Services/Process/IProcessExecutionService.cs
    AutoQAC/Services/Process/ProcessExecutionService.cs
  </files>
  <action>
**1. Create `AutoQAC/Models/TerminationResult.cs`:**
```csharp
namespace AutoQAC.Models;

public enum TerminationResult
{
    AlreadyExited,
    GracefulExit,
    GracePeriodExpired,
    ForceKilled
}
```

**2. Create `AutoQAC/Models/TrackedProcess.cs`:**
A record for PID file entries stored in `AutoQAC Data/autoqac-pids.json`:
```csharp
namespace AutoQAC.Models;

public sealed record TrackedProcess
{
    public int Pid { get; init; }
    public DateTime StartTime { get; init; }
    public string PluginName { get; init; } = string.Empty;
}
```

**3. Update `IProcessExecutionService` interface:**
Add these new members to the interface:
- `Task<TerminationResult> TerminateProcessAsync(Process process, bool forceKill = false, CancellationToken ct = default)` -- Escalating termination (graceful with 2.5s grace, or immediate force kill)
- `Task CleanOrphanedProcessesAsync(CancellationToken ct = default)` -- Detect and kill orphaned xEdit processes from PID file
- `Task TrackProcessAsync(Process process, string pluginName, CancellationToken ct = default)` -- Write PID entry to tracking file
- `Task UntrackProcessAsync(int pid, CancellationToken ct = default)` -- Remove PID entry from tracking file
- Add `TerminationResult` to the using statements / make it accessible

Keep all existing members unchanged.

**4. Implement `TerminateProcessAsync` in ProcessExecutionService:**

Replace the existing `TerminateProcessGracefullyAsync` with the new `TerminateProcessAsync` method implementing the escalation pattern from RESEARCH.md Pattern 1:

- **Graceful path (forceKill=false):** Call `process.CloseMainWindow()`. Check the return value -- if it returns `false` (expected with `CreateNoWindow=true`), skip the grace period and return `GracePeriodExpired` immediately (caller should escalate). If it returns `true`, wait up to 2500ms using `process.WaitForExitAsync()` with a linked CancellationTokenSource. If the process exits within the grace period, return `GracefulExit`. If the grace period expires, return `GracePeriodExpired`.
- **Force path (forceKill=true):** Call `process.Kill(entireProcessTree: true)` then `await process.WaitForExitAsync(ct)`. Return `ForceKilled`. Catch `InvalidOperationException` (process already exited) and return `AlreadyExited`. Catch `System.ComponentModel.Win32Exception` and log error.
- If `process.HasExited` is already true at the start, return `AlreadyExited`.

**5. Replace TCS-based wait in `ExecuteAsync` with `process.WaitForExitAsync()`:**
- Remove the `TaskCompletionSource<bool>` pattern entirely
- Remove `process.Exited += (s, e) => tcs.TrySetResult(true)` and `process.EnableRaisingEvents = true`
- Instead, after `process.Start()` and `BeginOutputReadLine()`/`BeginErrorReadLine()`, await `process.WaitForExitAsync(linkedToken)` directly
- On `OperationCanceledException`: determine if timeout or user cancel, then call `TerminateProcessAsync(process, forceKill: false, ct)` for the initial attempt (graceful). If the result is `GracePeriodExpired`, call `TerminateProcessAsync(process, forceKill: true, ct)` to force-kill.

**IMPORTANT: Do not rely on Process.Exited event anywhere.** Use WaitForExitAsync exclusively. This is a known .NET bug with Kill(entireProcessTree: true).

**IMPORTANT: Use structured Serilog logging** with the prefix patterns from RESEARCH.md:
- `[Orphan]` for orphan detection/cleanup
- `[Termination]` for process termination actions
  </action>
  <verify>
Run `dotnet build` -- project must compile without errors. Check that `TerminateProcessAsync` exists with both graceful and force paths. Check that the old TCS pattern is fully removed from `ExecuteAsync`.
  </verify>
  <done>
ProcessExecutionService uses `Process.Kill(entireProcessTree: true)` for force kill and `Process.WaitForExitAsync()` instead of the Exited event TCS. The TerminationResult enum and TrackedProcess model exist. No compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Add PID tracking, orphan cleanup, and semaphore timeout to ProcessExecutionService</name>
  <files>
    AutoQAC/Services/Process/ProcessExecutionService.cs
  </files>
  <action>
**1. Add PID tracking methods:**
- **`TrackProcessAsync`:** Read existing JSON array from `autoqac-pids.json` in the config directory (resolve using the same pattern as ConfigurationService -- `AutoQAC Data/` relative to base directory, or in debug mode search parent dirs). Add new entry `{ Pid, StartTime = process.StartTime, PluginName }`. Write back. Use `System.Text.Json.JsonSerializer` (built-in). If file doesn't exist, create it.
- **`UntrackProcessAsync`:** Read file, remove entry matching `pid`, write back. If file doesn't exist or is empty, no-op.
- **`CleanOrphanedProcessesAsync`:** Read PID file. For each entry, try `Process.GetProcessById(entry.Pid)`. Verify it is actually xEdit by checking: (a) process name contains known xEdit patterns (SSEEdit, FO4Edit, FO3Edit, FNVEdit, TES5VREdit, xEdit -- case-insensitive), AND (b) `process.StartTime` is within 5 seconds of tracked start time. If both match, call `process.Kill(entireProcessTree: true)` followed by `process.WaitForExitAsync()`. Log each action with `[Orphan]` prefix. After processing all entries, clear the PID file. Catch `ArgumentException` (process no longer exists) and `InvalidOperationException` (access denied) gracefully.

**2. Wire PID tracking into `ExecuteAsync`:**
- After `process.Start()`, call `await TrackProcessAsync(process, startInfo.Arguments, ct)` (use arguments as plugin name proxy, or accept pluginName as an additional optional parameter on ExecuteAsync -- prefer adding it as optional parameter: `string? pluginName = null`).
- In the finally block (or after `WaitForExitAsync` completes), call `await UntrackProcessAsync(process.Id, ct)`.

**3. Add `AcquireProcessSlotAsync` timeout per PROC-06:**
- Add a 60-second timeout to `_processSlots.WaitAsync()` as a safety net. If it times out, log a warning: "[Termination] Semaphore slot acquisition timed out after 60s -- possible deadlock". Throw `TimeoutException`.
- Also log a warning at 10 seconds using a `Task.Delay(10000)` race: `var acquired = await Task.WhenAny(slotTask, Task.Delay(10000, ct))`. If the delay wins, log warning but continue waiting.

**4. Ensure semaphore release in finally block:**
The `_processSlots.Release()` call MUST be in a `finally` block so the slot is always freed, even after cancellation or exception. This prevents deadlocking the semaphore after a cancelled run.

**IMPORTANT: Use structured Serilog logging** with the prefix patterns from RESEARCH.md:
- `[Orphan]` for orphan detection/cleanup
- `[Termination]` for process termination actions
  </action>
  <verify>
Run `dotnet build` -- project must compile without errors. Check that `CleanOrphanedProcessesAsync` reads PID file and validates process name + start time. Check that `AcquireProcessSlotAsync` has a timeout safety net. Check that `UntrackProcessAsync` is called in a finally block. Check that `_processSlots.Release()` is in a finally block.
  </verify>
  <done>
ProcessExecutionService tracks PIDs to a JSON file, cleans orphans on demand, has a 60-second semaphore timeout safety net, and always releases the semaphore slot in a finally block. No compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix CTS race in CleaningOrchestrator and add dual-path escalation stop</name>
  <files>
    AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  </files>
  <action>
**1. Update `ICleaningOrchestrator`:**
- Change `void StopCleaning()` to `Task StopCleaningAsync()` -- must be async because it calls `TerminateProcessAsync` which is async.
- Add `Task ForceStopCleaningAsync()` -- immediate force kill, no grace period.

**2. Fix the CTS race condition in CleaningOrchestrator (PROC-04):**

Replace the current `StopCleaning()` implementation with the safe pattern from RESEARCH.md Pattern 5:
```csharp
public async Task StopCleaningAsync()
{
    _logger.Information("[Termination] Graceful stop requested");
    CancellationTokenSource? cts;
    lock (_ctsLock)
    {
        cts = _cleaningCts;
    }
    try
    {
        cts?.Cancel();
    }
    catch (ObjectDisposedException)
    {
        _logger.Debug("[Termination] CTS already disposed -- cleaning likely already finished");
    }
}
```

**3. Implement the dual-path escalation model (per user decisions -- BOTH paths are required):**

The user decisions specify TWO COMPLEMENTARY escalation paths:
- **Path A (patient user):** First click -> graceful stop with 2.5s grace period. If grace period expires AND user hasn't clicked again -> prompt user "xEdit didn't stop gracefully. Force kill?" User must confirm force kill.
- **Path B (impatient user):** First click -> graceful stop. Second click DURING grace period -> immediate force kill, NO prompt.

Implementation approach -- the orchestrator holds a `Process?` reference to the currently running xEdit process:

Add these fields to CleaningOrchestrator:
```csharp
private volatile bool _isStopRequested;
private Process? _currentProcess;   // Set by ExecuteAsync callback, cleared on exit
private readonly object _processLock = new();
```

**Wiring the process reference:** The orchestrator needs a reference to the currently running Process object. Two options:
- (a) Add a callback/delegate parameter to `ProcessExecutionService.ExecuteAsync` that is invoked with the Process after Start(), OR
- (b) Have `ExecuteAsync` return a wrapper that includes the Process reference.

Prefer option (a): Add an optional `Action<Process>? onProcessStarted = null` parameter to `ExecuteAsync` (and `IProcessExecutionService`). The orchestrator passes a lambda that stores the process reference:
```csharp
await _processService.ExecuteAsync(startInfo, onProcessStarted: process =>
{
    lock (_processLock)
    {
        _currentProcess = process;
    }
}, pluginName: pluginName, ct: linkedToken);
```
Clear `_currentProcess = null` in the finally block of the per-plugin loop.

**StopCleaningAsync (first click -- graceful):**
```csharp
public async Task StopCleaningAsync()
{
    if (_isStopRequested)
    {
        // Path B: Second click during grace period -- immediate force kill, no prompt
        await ForceStopCleaningAsync();
        return;
    }

    _isStopRequested = true;
    _logger.Information("[Termination] Graceful stop requested");

    // Cancel the CTS (race-safe)
    CancellationTokenSource? cts;
    lock (_ctsLock) { cts = _cleaningCts; }
    try { cts?.Cancel(); }
    catch (ObjectDisposedException)
    {
        _logger.Debug("[Termination] CTS already disposed");
        return;
    }

    // Attempt graceful termination on the current process
    Process? proc;
    lock (_processLock) { proc = _currentProcess; }
    if (proc != null && !proc.HasExited)
    {
        var result = await _processService.TerminateProcessAsync(proc, forceKill: false);
        if (result == TerminationResult.GracePeriodExpired)
        {
            // Path A: Grace period expired naturally, user hasn't clicked again.
            // The ViewModel will check this result and prompt the user for confirmation.
            // Store the result so the ViewModel can react.
            _lastTerminationResult = result;
        }
    }
}
```

Add `private TerminationResult? _lastTerminationResult;` field and a public `TerminationResult? LastTerminationResult => _lastTerminationResult;` getter on the interface so the ViewModel can check if a prompt is needed after StopCleaningAsync returns.

**ForceStopCleaningAsync (second click or explicit force):**
```csharp
public async Task ForceStopCleaningAsync()
{
    _logger.Information("[Termination] Force stop requested -- killing process tree immediately");

    // Cancel the CTS if not already
    CancellationTokenSource? cts;
    lock (_ctsLock) { cts = _cleaningCts; }
    try { cts?.Cancel(); }
    catch (ObjectDisposedException) { }

    // Force kill the process tree
    Process? proc;
    lock (_processLock) { proc = _currentProcess; }
    if (proc != null && !proc.HasExited)
    {
        await _processService.TerminateProcessAsync(proc, forceKill: true);
    }
}
```

Reset `_isStopRequested = false` and `_lastTerminationResult = null` at the start of `StartCleaningAsync` and in its finally block.

**4. Add orphan cleanup call before cleaning:**

At the beginning of `StartCleaningAsync` (before validation), call:
```csharp
await _processService.CleanOrphanedProcessesAsync(ct).ConfigureAwait(false);
```
This requires adding `IProcessExecutionService` as a constructor dependency. Add it to the constructor alongside the existing services.

**5. Preserve partial results on cancellation:**

The current code already builds `pluginResults` as it goes. Add a specific `catch (OperationCanceledException)` block before the generic `catch (Exception ex)` that sets `wasCancelled = true` without rethrowing, and creates the session result. This way cancelled operations don't bubble up as errors.

**6. Register IProcessExecutionService in constructor:**

Add `IProcessExecutionService processService` to the constructor parameters and store as `_processService`. IProcessExecutionService is already registered as singleton in `ServiceCollectionExtensions.AddBusinessLogic()`, so no DI changes needed, just the constructor parameter.

**IMPORTANT**: Keep the `_ctsLock` as `object` (not `Lock`). Check the current code -- it uses `private readonly object _ctsLock = new();`. Keep this as-is for the lock pattern.
  </action>
  <verify>
Run `dotnet build` -- project must compile. Verify `StopCleaningAsync` captures CTS reference inside lock and calls Cancel outside. Verify the dual-path escalation: first call is graceful (Path A returns GracePeriodExpired if still running), second call is force kill (Path B skips prompt). Verify `LastTerminationResult` is exposed on the interface. Verify `CleanOrphanedProcessesAsync` is called at the start of `StartCleaningAsync`. Verify `OperationCanceledException` is caught separately and creates a session result with `WasCancelled = true`.
  </verify>
  <done>
CleaningOrchestrator has race-safe CTS handling, dual-path escalation (Path A: grace period -> prompt via LastTerminationResult; Path B: second click -> immediate force kill), orphan cleanup before cleaning, and proper OperationCanceledException handling with partial result preservation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update all callers and fix ALL affected tests for interface changes</name>
  <files>
    AutoQAC/ViewModels/MainWindowViewModel.cs
    AutoQAC/Views/MainWindow.axaml.cs
    AutoQAC.Tests/Services/CleaningOrchestratorTests.cs
    AutoQAC.Tests/ViewModels/MainWindowViewModelTests.cs
    AutoQAC.Tests/ViewModels/MainWindowViewModelInitializationTests.cs
    AutoQAC.Tests/ViewModels/ErrorDialogTests.cs
    AutoQAC.Tests/ViewModels/ProgressViewModelTests.cs
    AutoQAC.Tests/Services/CleaningServiceTests.cs
    AutoQAC.Tests/Integration/DependencyInjectionTests.cs
  </files>
  <action>
**1. Update MainWindowViewModel:**

Find where `StopCleaning()` is called (likely in a stop command). Change from:
```csharp
_orchestrator.StopCleaning();
```
to:
```csharp
await _orchestrator.StopCleaningAsync();
```

If the stop command is currently synchronous (e.g., `ReactiveCommand.Create(() => _orchestrator.StopCleaning())`), change it to async: `ReactiveCommand.CreateFromTask(() => _orchestrator.StopCleaningAsync())`.

Implement the dual-path escalation in the ViewModel stop command:
```csharp
// The stop command handler:
private async Task HandleStopAsync()
{
    await _orchestrator.StopCleaningAsync();

    // Check if grace period expired (Path A: user waited patiently)
    if (_orchestrator.LastTerminationResult == TerminationResult.GracePeriodExpired)
    {
        // Prompt user: "xEdit didn't stop gracefully. Force kill?"
        // NOTE: The actual dialog UI is wired here but the "Stopping..." spinner
        // UI blocking is deferred to Plan 01-02 or a future phase.
        // For now, just call ForceStopCleaningAsync -- the prompt UI will be
        // added when the "Stopping..." spinner is implemented.
        // TODO(01-02): Replace this with a user confirmation dialog
        await _orchestrator.ForceStopCleaningAsync();
    }
}
```

NOTE: The full "Stopping..." UI blocking spinner and the confirmation dialog are deferred to a future plan. For now, the escalation logic is wired so that: (a) second click = immediate force kill via the `_isStopRequested` flag in CleaningOrchestrator, and (b) the Path A prompt placeholder exists in the ViewModel for future UI work.

**2. Update MainWindow.axaml.cs if needed:**

If there are interaction handlers that call `StopCleaning()`, update them to use the async version.

**3. Search and update ALL affected test files:**

Search all test files for references to `IProcessExecutionService`, `ICleaningOrchestrator`, and `StopCleaning`. The following files are known to be affected (grep confirms 7 files):
- `AutoQAC.Tests/Services/CleaningOrchestratorTests.cs` -- Direct tests, mock updates needed
- `AutoQAC.Tests/ViewModels/MainWindowViewModelTests.cs` -- Mocks ICleaningOrchestrator
- `AutoQAC.Tests/ViewModels/MainWindowViewModelInitializationTests.cs` -- Mocks ICleaningOrchestrator
- `AutoQAC.Tests/ViewModels/ErrorDialogTests.cs` -- May mock ICleaningOrchestrator
- `AutoQAC.Tests/ViewModels/ProgressViewModelTests.cs` -- May mock ICleaningOrchestrator
- `AutoQAC.Tests/Services/CleaningServiceTests.cs` -- May reference IProcessExecutionService
- `AutoQAC.Tests/Integration/DependencyInjectionTests.cs` -- Tests DI registration

For each affected file:
- Update any `mock.Setup(x => x.StopCleaning())` to `mock.Setup(x => x.StopCleaningAsync()).Returns(Task.CompletedTask)`
- Update any direct calls to `orchestrator.StopCleaning()` to `await orchestrator.StopCleaningAsync()`
- Add the new `IProcessExecutionService` mock to CleaningOrchestrator constructor in tests that create it directly
- Add `ForceStopCleaningAsync` and `LastTerminationResult` to interface mocks where needed
- Update DI integration tests if the new constructor parameters affect resolution

Run `dotnet test` after ALL updates to verify no tests are broken.

**IMPORTANT**: The OperationCanceledException handling change in CleaningOrchestrator may affect test expectations. Review tests that verify cancellation behavior and update assertions if needed.
  </action>
  <verify>
Run `dotnet build` -- project must compile without errors. Run `dotnet test` -- ALL tests must pass. Verify that the stop command in MainWindowViewModel uses the dual-path escalation. Verify that no test file still references the old `StopCleaning()` (synchronous) method.
  </verify>
  <done>
All callers updated for async StopCleaning. ALL affected tests (7 test files) updated and passing. The stop command implements dual-path escalation. The project builds and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds with zero errors and zero warnings related to the changed files
2. `dotnet test` passes ALL tests (including all 7 affected test files updated for interface changes)
3. ProcessExecutionService no longer uses the `Exited` event or `TaskCompletionSource` pattern
4. ProcessExecutionService uses `Process.Kill(entireProcessTree: true)` for force termination
5. ProcessExecutionService tracks PIDs to `autoqac-pids.json` and cleans orphans
6. CleaningOrchestrator `StopCleaningAsync` captures CTS reference inside lock, calls Cancel outside
7. Dual-path escalation works: Path A (patient user) = graceful -> grace period expires -> LastTerminationResult=GracePeriodExpired (ViewModel prompts). Path B (impatient user) = second click during grace period -> immediate force kill, no prompt.
8. OperationCanceledException is caught separately and preserves partial results
9. No ObjectDisposedException is possible from the CTS race
10. Restart-after-cancel verification: (a) no stale PID file entries after clean termination (UntrackProcessAsync in finally block), (b) semaphore slot is always released in finally block, (c) CTS is properly disposed and recreated, (d) `_isStopRequested` and `_lastTerminationResult` are reset at start of StartCleaningAsync
</verification>

<success_criteria>
- Process termination uses the escalation pattern: graceful close -> grace period -> force kill tree
- Dual-path escalation honors BOTH user decisions: Path A (prompt after natural grace period expiry) and Path B (second click = immediate force kill, no prompt)
- PID file tracking enables orphan cleanup on startup and before cleaning runs
- CancellationTokenSource race condition between StopCleaning and Dispose is eliminated
- Partial cleaning results are preserved when user cancels mid-session
- Starting a new cleaning session after cancelling never fails (verified: no stale PIDs, semaphore released in finally, CTS recreated, stop flags reset)
- All existing tests pass after updates for the interface changes
- Semaphore slot acquisition has a 60-second timeout safety net
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hardening/01-01-SUMMARY.md`
</output>
