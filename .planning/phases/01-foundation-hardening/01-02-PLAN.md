---
phase: 01-foundation-hardening
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - AutoQAC/Services/State/IStateService.cs
  - AutoQAC/Services/State/StateService.cs
  - AutoQAC/Services/Configuration/IConfigurationService.cs
  - AutoQAC/Services/Configuration/ConfigurationService.cs
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/App.axaml.cs
autonomous: true

must_haves:
  truths:
    - "Rapid property changes in the UI (toggling settings, selecting plugins) never cause the application to freeze or deadlock"
    - "User can change multiple settings in quick succession and all changes persist to disk even if the app is closed shortly after"
    - "Configuration changes made just before starting a cleaning run are flushed to disk before xEdit launches"
    - "If a config save fails after retries, the in-memory config reverts to the last known-good config from disk and a non-blocking warning is shown"
    - "StateService.UpdateState never deadlocks even when subscribers read CurrentState from their callbacks"
  artifacts:
    - path: "AutoQAC/Services/State/StateService.cs"
      provides: "Deadlock-free state updates with OnNext emitted outside the lock"
      contains: "OnNext.*outside.*lock|_stateSubject.OnNext\\(newState\\)"
    - path: "AutoQAC/Services/Configuration/ConfigurationService.cs"
      provides: "Debounced config saves with Rx Throttle, retry, revert-on-failure, and flush"
      contains: "Throttle|FlushPendingSavesAsync|_lastKnownGoodConfig"
    - path: "AutoQAC/Services/Configuration/IConfigurationService.cs"
      provides: "FlushPendingSavesAsync method on the interface"
      contains: "FlushPendingSavesAsync"
    - path: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      provides: "Pre-clean config flush call"
      contains: "FlushPendingSavesAsync"
    - path: "AutoQAC/App.axaml.cs"
      provides: "App shutdown flush hook"
      contains: "FlushPendingSavesAsync|ShutdownRequested|OnClosing"
  key_links:
    - from: "StateService.UpdateState"
      to: "BehaviorSubject.OnNext"
      via: "Capture inside lock, emit outside"
      pattern: "lock.*\\{[^}]*\\}.*OnNext"
    - from: "ConfigurationService.SaveUserConfigAsync"
      to: "Debounce pipeline"
      via: "Rx Throttle (500ms) batches rapid changes"
      pattern: "Throttle.*500|_saveRequests"
    - from: "CleaningOrchestrator.StartCleaningAsync"
      to: "ConfigurationService.FlushPendingSavesAsync"
      via: "Called before xEdit launch to guarantee fresh config"
      pattern: "FlushPendingSavesAsync.*before.*clean|await.*_configService.*Flush"
    - from: "App shutdown"
      to: "ConfigurationService.FlushPendingSavesAsync"
      via: "Called during application exit to prevent data loss"
      pattern: "ShutdownRequested.*Flush|OnClosing.*Flush"
---

<objective>
Fix the StateService deadlock (BehaviorSubject.OnNext called inside a Lock) and add debounced configuration saves with pre-clean flush and app-shutdown flush, so that rapid UI interactions never freeze the app and config changes always persist.

Purpose: StateService currently calls `_stateSubject.OnNext(newState)` while holding `_lock`, which can deadlock if a subscriber on the UI thread tries to read `CurrentState` (which also acquires `_lock`). ConfigurationService performs synchronous immediate disk writes for every config change, causing lag during rapid setting toggles and risking data loss if the app crashes mid-write. This plan fixes both: the StateService emits outside the lock, and ConfigurationService uses Rx `Throttle` for debounced writes with retry and revert-on-failure.

Output: Fixed StateService with lock-free emission, ConfigurationService with debounced saves + FlushPendingSavesAsync, pre-clean flush in CleaningOrchestrator, and app-shutdown flush in App.axaml.cs.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hardening/01-CONTEXT.md
@.planning/phases/01-foundation-hardening/01-RESEARCH.md
@.planning/phases/01-foundation-hardening/01-01-SUMMARY.md
@AutoQAC/Services/State/IStateService.cs
@AutoQAC/Services/State/StateService.cs
@AutoQAC/Services/Configuration/IConfigurationService.cs
@AutoQAC/Services/Configuration/ConfigurationService.cs
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/App.axaml.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix StateService deadlock -- emit OnNext outside the lock</name>
  <files>
    AutoQAC/Services/State/IStateService.cs
    AutoQAC/Services/State/StateService.cs
  </files>
  <action>
**1. Fix `UpdateState` in StateService (STAT-01):**

Replace the current pattern where `_stateSubject.OnNext(newState)` is called INSIDE the lock:

```csharp
// CURRENT (deadlock-prone):
public void UpdateState(Func<AppState, AppState> updateFunc)
{
    lock (_lock)
    {
        var newState = updateFunc(_stateSubject.Value);
        _stateSubject.OnNext(newState);  // DANGER: subscribers may re-enter
    }
}
```

With the capture-then-emit pattern from RESEARCH.md Pattern 3:

```csharp
// FIXED (deadlock-free):
public void UpdateState(Func<AppState, AppState> updateFunc)
{
    AppState newState;
    lock (_lock)
    {
        newState = updateFunc(_stateSubject.Value);
    }
    // Emit OUTSIDE the lock -- subscribers can safely read CurrentState
    _stateSubject.OnNext(newState);
}
```

**2. Fix `CurrentState` getter:**

Remove the lock from the getter. `BehaviorSubject.Value` is thread-safe for reads -- the lock was only needed to protect the read-modify-write cycle in `UpdateState`, which is already handled by the lock around the update function.

```csharp
// CURRENT:
public AppState CurrentState
{
    get
    {
        lock (_lock) { return _stateSubject.Value; }
    }
}

// FIXED:
public AppState CurrentState => _stateSubject.Value;
```

**3. Fix `StartCleaning` method:**

The current `StartCleaning` method acquires `_lock` separately from its `UpdateState` call:
```csharp
public void StartCleaning(List<PluginInfo> plugins)
{
    lock (_lock)
    {
        _currentSessionResults.Clear();
        _cleaningStartTime = DateTime.Now;
    }
    UpdateState(s => s with { ... });
}
```

This is fine -- the `lock (_lock)` only protects `_currentSessionResults` and `_cleaningStartTime`, not the state emission. No change needed here.

**4. Fix `AddDetailedCleaningResult`:**

Same pattern -- the `lock (_lock)` around `_currentSessionResults.Add(result)` is fine because it's a separate data structure. The `AddCleaningResult` call goes through `UpdateState` which now emits outside the lock. No change needed.

**5. Fix `FinishCleaningWithResults`:**

The `lock (_lock)` around `_lastSessionResult = sessionResult` is fine. The `UpdateState` call and `_cleaningCompletedSubject.OnNext(sessionResult)` are already outside the lock. No change needed.

**6. Verify `IStateService` interface:**

No interface changes needed for the deadlock fix -- the fix is purely internal to StateService.

**7. Add termination state tracking to IStateService and StateService:**

Add a new property to track whether termination is in progress (per user decision: "Block all controls with a 'Stopping...' spinner"):

In `IStateService`, add:
```csharp
/// <summary>
/// Observable that emits true when stop/termination is in progress.
/// </summary>
IObservable<bool> IsTerminatingChanged { get; }
```

In `StateService`, add:
```csharp
private readonly BehaviorSubject<bool> _isTerminatingSubject = new(false);
public IObservable<bool> IsTerminatingChanged => _isTerminatingSubject.AsObservable();

public void SetTerminating(bool isTerminating)
{
    _isTerminatingSubject.OnNext(isTerminating);
}
```

Also add `void SetTerminating(bool isTerminating)` to `IStateService`.

Dispose `_isTerminatingSubject` in the `Dispose` method.

This observable will be consumed by the ViewModel in a future UI plan to show the "Stopping..." spinner.
  </action>
  <verify>
Run `dotnet build` -- project must compile. Verify that `_stateSubject.OnNext(newState)` is called OUTSIDE the lock in `UpdateState`. Verify that `CurrentState` getter does NOT acquire the lock. Verify `IsTerminatingChanged` observable is added and properly disposed.
  </verify>
  <done>
StateService emits `OnNext` outside the lock, preventing subscriber deadlocks. `CurrentState` getter is lock-free. `IsTerminatingChanged` observable is available for UI termination state. No compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add debounced config saves with retry, revert, and flush</name>
  <files>
    AutoQAC/Services/Configuration/IConfigurationService.cs
    AutoQAC/Services/Configuration/ConfigurationService.cs
  </files>
  <action>
**1. Update `IConfigurationService`:**

Add:
```csharp
/// <summary>
/// Force-flush any pending debounced config saves to disk immediately.
/// Call before starting xEdit and during app shutdown.
/// </summary>
Task FlushPendingSavesAsync(CancellationToken ct = default);
```

**2. Add debounce infrastructure to ConfigurationService:**

Add these private fields:
```csharp
private readonly Subject<UserConfiguration> _saveRequests = new();
private UserConfiguration? _lastKnownGoodConfig;
private UserConfiguration? _pendingConfig;
private readonly IDisposable _debounceSubscription;
```

In the constructor, set up the Rx Throttle pipeline (per RESEARCH.md Pattern 4):
```csharp
_debounceSubscription = _saveRequests
    .Throttle(TimeSpan.FromMilliseconds(500))
    .Subscribe(config =>
    {
        // Fire-and-forget the save -- errors are handled inside
        _ = SaveToDiskWithRetryAsync(config);
    });
```

NOTE: Use `System.Reactive.Linq` for `Throttle` (already imported in the file).

**3. Create the retry + revert save method:**

```csharp
private async Task SaveToDiskWithRetryAsync(UserConfiguration config, CancellationToken ct = default)
{
    const int maxRetries = 2;
    var path = Path.Combine(_configDirectory, UserConfigFile);

    for (int attempt = 0; attempt <= maxRetries; attempt++)
    {
        try
        {
            await _fileLock.WaitAsync(ct).ConfigureAwait(false);
            try
            {
                var content = _serializer.Serialize(config);
                await File.WriteAllTextAsync(path, content, ct).ConfigureAwait(false);
                _lastKnownGoodConfig = config;
                _pendingConfig = null;
                _logger.Information("[Config] Debounced save completed successfully");
                _configChanges.OnNext(config);
                return;
            }
            finally
            {
                _fileLock.Release();
            }
        }
        catch (Exception ex) when (attempt < maxRetries)
        {
            _logger.Warning("[Config] Save failed (attempt {Attempt}/{MaxAttempts}): {Message}",
                attempt + 1, maxRetries + 1, ex.Message);
            await Task.Delay(100, ct).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            _logger.Error(ex, "[Config] Save failed after {MaxRetries} retries. Reverting to last known good config.",
                maxRetries + 1);

            // Revert in-memory to last known good (per user decision: "revert to last known-good config on disk")
            if (_lastKnownGoodConfig != null)
            {
                _pendingConfig = null;
                _configChanges.OnNext(_lastKnownGoodConfig);
                _logger.Warning("[Config] Reverted to last known good configuration");
            }
            // The non-blocking warning to UI is emitted via _configChanges observable
            // (subscribers can check for the revert pattern if needed)
        }
    }
}
```

**4. Modify `SaveUserConfigAsync` to use debounce:**

Change the existing `SaveUserConfigAsync` to schedule a debounced save instead of writing immediately:

```csharp
public async Task SaveUserConfigAsync(UserConfiguration config, CancellationToken ct = default)
{
    // Store the pending config in memory (always up-to-date)
    _pendingConfig = config;
    // Schedule debounced write to disk
    _saveRequests.OnNext(config);
}
```

The method signature stays `Task` for interface compatibility, but the actual disk write is deferred. The in-memory state is always current. This means `LoadUserConfigAsync` must also check `_pendingConfig`:

**5. Modify `LoadUserConfigAsync` to prefer in-memory pending config:**

If `_pendingConfig` is not null, return it instead of reading from disk. This ensures that rapid read-after-write sequences get the latest config even if the debounced save hasn't fired yet.

```csharp
public async Task<UserConfiguration> LoadUserConfigAsync(CancellationToken ct = default)
{
    // Return pending in-memory config if available (debounced save may not have fired yet)
    if (_pendingConfig != null) return _pendingConfig;

    // ... rest of existing load logic (migration, file read) ...
}
```

Also, after successfully loading from disk in the existing path, set `_lastKnownGoodConfig` to the loaded config.

**6. Implement `FlushPendingSavesAsync`:**

```csharp
public async Task FlushPendingSavesAsync(CancellationToken ct = default)
{
    var config = _pendingConfig;
    if (config == null)
    {
        _logger.Debug("[Config] No pending config changes to flush");
        return;
    }

    _logger.Information("[Config] Flushing pending config saves to disk");
    await SaveToDiskWithRetryAsync(config, ct).ConfigureAwait(false);
}
```

**7. Update `Dispose`:**

Add disposal of the debounce subscription and the new subject:
```csharp
public void Dispose()
{
    _debounceSubscription.Dispose();
    _saveRequests.Dispose();
    _fileLock.Dispose();
    _configChanges.Dispose();
    _skipListChanges.Dispose();
}
```

NOTE: The `_saveRequests` Subject is different from the existing `_configChanges` Subject. `_saveRequests` feeds into the Throttle pipeline. `_configChanges` is the outgoing observable that notifies subscribers of config changes.

**IMPORTANT**: Use `[Config]` prefix in all log messages per RESEARCH.md logging format.
  </action>
  <verify>
Run `dotnet build` -- project must compile. Verify `SaveUserConfigAsync` schedules a debounced write (not immediate disk I/O). Verify `LoadUserConfigAsync` returns `_pendingConfig` if available. Verify `FlushPendingSavesAsync` forces immediate write. Verify retry logic attempts up to 3 times (initial + 2 retries) and reverts to last known good on failure. Verify the debounce subscription is disposed properly.
  </verify>
  <done>
ConfigurationService uses Rx Throttle for 500ms debounced saves. Rapid config changes are batched. FlushPendingSavesAsync forces immediate write. Retry with revert-on-failure is implemented. LoadUserConfigAsync returns in-memory pending config when available. No compilation errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire pre-clean flush and app-shutdown flush</name>
  <files>
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
    AutoQAC/App.axaml.cs
  </files>
  <action>
**1. Add pre-clean config flush to CleaningOrchestrator:**

In `StartCleaningAsync`, after the orphan cleanup call (added in Plan 01-01) and before validation, add:

```csharp
// Flush any pending config saves before launching xEdit
// (per user decision: "Always force-flush pending config saves before launching xEdit")
await _configService.FlushPendingSavesAsync(ct).ConfigureAwait(false);
```

This ensures xEdit always runs with up-to-date configuration. Place it right before the "1. Validate configuration" comment.

**2. Add app-shutdown flush to App.axaml.cs:**

In `OnFrameworkInitializationCompleted`, after setting up the MainWindow, add a shutdown handler:

```csharp
if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
{
    // ... existing MainWindow setup ...

    desktop.ShutdownRequested += (sender, args) =>
    {
        // Flush pending config saves before app exits (per user decision)
        // Synchronous wait is acceptable during app shutdown
        try
        {
            configService.FlushPendingSavesAsync().GetAwaiter().GetResult();
        }
        catch (Exception ex)
        {
            // Log but don't prevent shutdown
            logger.Warning("Failed to flush config on shutdown: {Message}", ex.Message);
        }
    };
}
```

NOTE: `GetAwaiter().GetResult()` is used here because Avalonia's `ShutdownRequested` handler is synchronous. This is the one place where synchronous wait is acceptable (app is shutting down, no risk of deadlock on an already-disposed UI thread).

**3. Run tests:**

Run `dotnet test` to verify no regressions. The ConfigurationService changes may affect tests that mock `SaveUserConfigAsync` or `LoadUserConfigAsync` -- update any test expectations that assume immediate disk writes.

Check for any tests in `AutoQAC.Tests/Services/` that test ConfigurationService directly (e.g., `ConfigurationServiceSkipListTests.cs`) and ensure they still pass. If tests rely on `SaveUserConfigAsync` having written to disk synchronously, they may need to call `FlushPendingSavesAsync()` in the test setup or assertions.
  </action>
  <verify>
Run `dotnet build` -- project must compile. Run `dotnet test` -- all tests pass. Verify `FlushPendingSavesAsync` is called in CleaningOrchestrator before validation. Verify the app shutdown handler calls `FlushPendingSavesAsync`. Check that ConfigurationService tests still pass (may need flush calls in test assertions).
  </verify>
  <done>
Pre-clean config flush guarantees fresh config before xEdit launches. App-shutdown flush prevents data loss on close. All tests pass. The full debounce pipeline is wired end-to-end: setting change -> debounce (500ms) -> disk write, with pre-clean flush and app-exit flush as safety nets.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds with zero errors
2. `dotnet test` passes all tests
3. `StateService.UpdateState` emits `OnNext` OUTSIDE the lock
4. `StateService.CurrentState` getter does NOT acquire the lock
5. `ConfigurationService.SaveUserConfigAsync` does NOT write to disk immediately (uses debounce)
6. `ConfigurationService.FlushPendingSavesAsync` forces an immediate write
7. `ConfigurationService` retries failed saves up to 3 times, then reverts to last known good
8. `CleaningOrchestrator.StartCleaningAsync` calls `FlushPendingSavesAsync` before launching xEdit
9. `App.axaml.cs` calls `FlushPendingSavesAsync` on application shutdown
10. Rapid `UpdateState` calls from different threads do not cause application freeze
</verification>

<success_criteria>
- StateService deadlock is eliminated -- OnNext is always outside the lock
- Config saves are debounced at 500ms, batching rapid changes into one disk write
- Pre-clean flush guarantees config is on disk before xEdit launches
- App-shutdown flush guarantees pending changes are saved before exit
- Failed saves retry twice then revert to last known good config from disk
- All existing tests pass after updates
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hardening/01-02-SUMMARY.md`
</output>
