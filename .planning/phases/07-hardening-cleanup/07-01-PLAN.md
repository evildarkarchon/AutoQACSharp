---
phase: 07-hardening-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC.Tests/AutoQAC.Tests.csproj
  - AutoQAC.Tests/Services/ProcessExecutionServiceTests.cs
  - AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs
  - AutoQAC.Tests/Services/ConfigurationServiceSkipListTests.cs
  - AutoQAC.Tests/Services/StateServiceTests.cs
  - AutoQAC.Tests/Services/PluginValidationServiceTests.cs
autonomous: true

must_haves:
  truths:
    - "ProcessExecutionService TerminateProcessAsync and CleanOrphanedProcessesAsync are tested through mocked IProcessExecutionService at the orchestrator level, plus unit tests for non-process-spawning paths (startup failure, disposal, PID file edge cases via temp directories)"
    - "LegacyMigrationService has tests covering no-legacy-file, C#-config-exists, parse-failure, write-failure, backup-failure, and full-success paths"
    - "ConfigurationService GetSkipListAsync with GameType.Unknown returns only Universal entries (maps to Unknown key which has no match in skip list config)"
    - "StateService concurrent UpdateState calls from multiple tasks produce consistent results"
    - "PluginValidationService has tests for null FullPath, whitespace-only FullPath, and forward-slash relative paths"
    - "Coverlet collects coverage on every dotnet test run via MSBuild properties"
  artifacts:
    - path: "AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs"
      provides: "LegacyMigrationService unit tests"
      min_lines: 100
    - path: "AutoQAC.Tests/AutoQAC.Tests.csproj"
      provides: "Test project with coverlet.msbuild package and coverage MSBuild properties"
      contains: "coverlet.msbuild"
  key_links:
    - from: "AutoQAC.Tests/Services/ProcessExecutionServiceTests.cs"
      to: "AutoQAC/Services/Process/IProcessExecutionService.cs"
      via: "Tests use Mock<IProcessExecutionService> at orchestrator level and test non-process-spawning paths directly"
      pattern: "Mock<IProcessExecutionService>|ProcessExecutionService"
    - from: "AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs"
      to: "AutoQAC/Services/Configuration/LegacyMigrationService.cs"
      via: "Tests use temp directory constructor parameter for file system isolation"
      pattern: "LegacyMigrationService.*_testDirectory"
---

<objective>
Fill targeted test coverage gaps for specific requirements TEST-01 through TEST-05, and set up Coverlet MSBuild integration so every `dotnet test` run produces coverage data.

Purpose: The existing test suite has 475+ tests but specific critical paths identified in the requirements lack coverage -- process termination edge cases (TEST-01), migration failure paths (TEST-02), Unknown GameType skip list behavior (TEST-03), concurrent state updates (TEST-04), and non-rooted path validation variants (TEST-05). Coverage tooling setup ensures we can measure progress.

Output: 5 test files modified/created with new test cases, test project csproj updated with Coverlet MSBuild properties, all tests pass with coverage output.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hardening-cleanup/07-CONTEXT.md
@.planning/phases/07-hardening-cleanup/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Coverage tooling setup + ProcessExecutionService and LegacyMigrationService tests</name>
  <files>
    AutoQAC.Tests/AutoQAC.Tests.csproj
    AutoQAC.Tests/Services/ProcessExecutionServiceTests.cs
    AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs
  </files>
  <action>
**Step 1: Coverage tooling setup**

Add `coverlet.msbuild` package to AutoQAC.Tests.csproj alongside existing `coverlet.collector`:
```xml
<PackageReference Include="coverlet.msbuild" Version="6.0.4" />
```

Add MSBuild properties to AutoQAC.Tests.csproj PropertyGroup:
```xml
<CollectCoverage>true</CollectCoverage>
<CoverletOutputFormat>cobertura</CoverletOutputFormat>
<CoverletOutput>./TestResults/coverage/</CoverletOutput>
<Include>[AutoQAC]*</Include>
<Exclude>[AutoQAC.Tests]*</Exclude>
<ExcludeByAttribute>ExcludeFromCodeCoverage</ExcludeByAttribute>
```

Also add `TestResults/` to .gitignore if not already present.

**Step 2: ProcessExecutionService unit tests (TEST-01)**

IMPORTANT: Read the current ProcessExecutionServiceTests.cs and ProcessExecutionService.cs first to verify APIs.

Per user decision: "Unit tests only (with mocks/stubs) -- no integration tests with real file I/O or process spawning." The existing tests spawn real cmd.exe processes which violates this constraint. The new tests MUST NOT spawn any real processes.

**Strategy:** ProcessExecutionService has hard dependencies on System.Diagnostics.Process (not mockable). For termination and orphan cleanup logic, test through Mock<IProcessExecutionService> at the CleaningOrchestrator level. For ProcessExecutionService directly, only test paths that do NOT require real processes:

1. **Replace existing cmd.exe-spawning tests** -- The existing 7 tests in ProcessExecutionServiceTests.cs all spawn real cmd.exe processes. Replace them with tests that do NOT spawn processes:

   a. **ExecuteAsync_WhenProcessNotFound_ShouldReturnFailedResult** -- KEEP as-is. This test uses a nonexistent exe name, which throws on Process.Start (no real process spawns). This is a valid unit test.

   b. **Dispose_ShouldPreventFurtherExecution** -- KEEP as-is. This test disposes the service and verifies ObjectDisposedException is thrown before any process is spawned. Valid unit test.

   c. **REMOVE the following tests** that spawn cmd.exe: ExecuteAsync_WhenCancelled_ShouldTerminateProcess, ExecuteAsync_WhenTimeout_ShouldTerminateAndReturnTimedOut, ExecuteAsync_ShouldCaptureOutputViaProgress, ExecuteAsync_ShouldReturnCorrectExitCode, ExecuteAsync_ShouldCaptureErrorOutput.

2. **Add new orchestrator-level tests** for TerminateProcessAsync and CleanOrphanedProcessesAsync via Mock<IProcessExecutionService>:

   Read CleaningOrchestrator.cs to understand how it calls IProcessExecutionService. Add tests in ProcessExecutionServiceTests.cs (or a new CleaningOrchestratorTerminationTests.cs file if it makes more sense) that:

   a. **Orchestrator_StopCleaning_CallsTerminateProcessAsync** -- Mock IProcessExecutionService.TerminateProcessAsync to return TerminationResult.GracefulExit. Verify it was called when the orchestrator is asked to stop.

   b. **Orchestrator_StopCleaning_ForceKill_EscalatesOnGracePeriodExpired** -- Mock TerminateProcessAsync to return GracePeriodExpired on first call (forceKill=false), then ForceKilled on second call (forceKill=true). Verify escalation behavior.

   c. **Orchestrator_Startup_CallsCleanOrphanedProcessesAsync** -- Verify that when the orchestrator initializes or starts a cleaning run, it calls CleanOrphanedProcessesAsync.

3. **Add PID file logic tests using temp directories** (these are standard unit tests -- temp directory usage for testing file operations is acceptable C# unit test practice when the path is injectable or test-controlled):

   a. **UntrackProcessAsync_NoPidFile_ReturnsWithoutError** -- Create ProcessExecutionService instance. When no PID file exists at the resolved path, verify UntrackProcessAsync(99999) returns without throwing.

   NOTE: Since GetPidFilePath() is private and uses AppContext.BaseDirectory with DEBUG directory walking, PID file tests may not be practical to unit test without refactoring the path resolution. If the PID file path cannot be controlled in tests, skip these tests and document the limitation. Accept limited unit test coverage for hard-to-mock System.Diagnostics.Process interactions per the checker's fix hint.

**Step 3: LegacyMigrationService tests (TEST-02)**

Create NEW file: AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs

LegacyMigrationService constructor accepts `string? configDirectory` parameter -- use temp directory for isolation. This is standard C# unit test practice: the constructor parameter makes the service's file paths injectable, so temp directory usage is NOT integration testing. The user's "no real file I/O" constraint refers to tests depending on real application data directories, external services, or production file locations.

Test cases to implement:

1. **MigrateIfNeeded_NoLegacyFile_ReturnsNotNeeded** -- Empty temp dir, call MigrateIfNeededAsync. Assert Attempted=false, Success=true.

2. **MigrateIfNeeded_CSharpConfigExists_ReturnsNotNeeded** -- Create both legacy and current config files. Call MigrateIfNeededAsync. Assert Attempted=false, Success=true (bootstrap only, no merge).

3. **MigrateIfNeeded_ValidLegacyConfig_MigratesSuccessfully** -- Create only "AutoQAC Config.yaml" with valid YAML content:
   ```yaml
   XEditPath: C:\SSEEdit\SSEEdit.exe
   LoadOrderPath: C:\Users\test\plugins.txt
   ```
   Call MigrateIfNeededAsync. Assert Attempted=true, Success=true, MigratedFiles contains "AutoQAC Config.yaml". Verify "AutoQAC Settings.yaml" was created. Verify backup in migration_backup/ subdirectory. Verify legacy file was deleted.

4. **MigrateIfNeeded_InvalidYaml_ReturnsFailure** -- Create "AutoQAC Config.yaml" with invalid YAML (e.g., `{{{invalid`). Assert Attempted=true, Success=false, FailedFiles contains "AutoQAC Config.yaml".

5. **MigrateIfNeeded_EmptyLegacyFile_ReturnsFailure** -- Create empty "AutoQAC Config.yaml". Assert Attempted=true, Success=false (deserializer returns null).

6. **MigrateIfNeeded_WriteFailure_ReturnsFailure** -- Create valid legacy config. Make the destination path fail (e.g., create a directory named "AutoQAC Settings.yaml" to cause write failure). Assert Attempted=true, Success=false.

7. **MigrateIfNeeded_BackupFailure_KeepsOriginal** -- Create valid legacy config. Make backup subdirectory path fail (e.g., create a file named "migration_backup" to block directory creation). Assert Attempted=true, Success=false, WarningMessage mentions backup. Verify original legacy file still exists (not deleted since backup failed).

All tests should use `IDisposable` pattern to clean up temp directories.
  </action>
  <verify>
Run `dotnet test AutoQAC.Tests` -- all existing tests plus new tests pass. Verify coverage output appears in AutoQAC.Tests/TestResults/coverage/ directory. Verify LegacyMigrationServiceTests.cs exists and contains at least 7 test methods. Verify ProcessExecutionServiceTests.cs no longer spawns cmd.exe processes (no "cmd.exe" string in the file, except possibly in comments explaining why they were removed).
  </verify>
  <done>
ProcessExecutionService termination and orphan cleanup are tested through mocked IProcessExecutionService at the orchestrator level -- no real cmd.exe processes spawned. LegacyMigrationService has dedicated test file covering all 7 migration paths (no-legacy, C#-exists, valid-migration, invalid-YAML, empty-file, write-failure, backup-failure) using injectable temp directories. Coverlet MSBuild properties are configured and produce Cobertura XML on every test run.
  </done>
</task>

<task type="auto">
  <name>Task 2: ConfigurationService skip list, StateService concurrent, and PluginValidationService path tests</name>
  <files>
    AutoQAC.Tests/Services/ConfigurationServiceSkipListTests.cs
    AutoQAC.Tests/Services/StateServiceTests.cs
    AutoQAC.Tests/Services/PluginValidationServiceTests.cs
  </files>
  <action>
IMPORTANT: Read ALL three existing test files AND their corresponding service implementations before writing any tests. Verify the exact API signatures of every method being tested.

**Step 1: ConfigurationService skip list with GameType.Unknown (TEST-03)**

Add to existing ConfigurationServiceSkipListTests.cs:

1. **GetSkipListAsync_UnknownGameType_ReturnsOnlyUniversalEntries** -- Set up Main.yaml with:
   ```yaml
   Data:
     SkipLists:
       SSE:
         - Skyrim.esm
       Universal:
         - Update.esm
   ```
   And Settings.yaml with empty SkipLists. Call GetSkipListAsync(GameType.Unknown). The GetGameKey method maps Unknown to "Unknown" string. Since "Unknown" won't match any key in SkipLists, only the Universal entries should be returned. Assert result contains only "Update.esm".

2. **GetSkipListAsync_UnknownGameType_NoUniversal_ReturnsEmpty** -- Set up configs with no Universal key. Call GetSkipListAsync(GameType.Unknown). Assert result is empty.

**Step 2: StateService concurrent edge cases (TEST-04)**

Add to existing StateServiceTests.cs:

1. **ConcurrentUpdateState_RapidToggling_SettlesCorrectly** -- Fire 100 rapid UpdateState calls alternating IsCleaning true/false from Task.Run. After all complete, verify the final state matches the last call's value. Use Task.WhenAll to wait. This tests the volatile _currentState field correctness.

2. **ConcurrentUpdateState_MultiplePropertyUpdates_NoneAreLost** -- From 10 concurrent tasks, each update a different property (e.g., different LoadOrderPath values indexed by task). After all complete, verify the final state has the last writer's value for each property. This validates no torn reads.

3. **StateChanged_RapidUpdates_AllEmitted** -- Subscribe to StateChanged observable, fire 50 rapid UpdateState calls, verify at least 50 emissions were observed (no dropped events from the BehaviorSubject).

Review the StateService API carefully -- it may use UpdateState with an Action<AppState> mutator or separate methods like UpdateConfigurationPaths, SetIsCleaning, etc. Use the actual API.

**Step 3: PluginValidationService non-rooted path variants (TEST-05)**

Add to existing PluginValidationServiceTests.cs:

1. **ValidatePluginFile_NullFullPath_ReturnsNotFound** -- Create PluginInfo with FullPath = null (if nullable) or empty string. Assert NotFound. Note: FullPath is `required string` so test with empty string and whitespace.

2. **ValidatePluginFile_WhitespaceOnlyFullPath_ReturnsNotFound** -- PluginInfo with FullPath = "   ". Assert NotFound.

3. **ValidatePluginFile_ForwardSlashRelativePath_ReturnsNotFound** -- PluginInfo with FullPath = "mods/Skyrim.esm". Assert NotFound (not rooted).

4. **ValidatePluginFile_DotRelativePath_ReturnsNotFound** -- PluginInfo with FullPath = "./plugins/Test.esp". Assert NotFound.

5. **ValidatePluginFile_BackslashRelativePath_ReturnsNotFound** -- PluginInfo with FullPath = "mods\\Skyrim.esm". Assert NotFound.

Read the ValidatePluginFile implementation to confirm it checks IsPathRooted and handles empty/whitespace FullPath. Adjust test expectations if the implementation handles these differently.
  </action>
  <verify>
Run `dotnet test AutoQAC.Tests` -- all tests pass including the new ones. Verify ConfigurationServiceSkipListTests has Unknown GameType tests. Verify StateServiceTests has new concurrent edge case tests. Verify PluginValidationServiceTests has 4+ new non-rooted path variant tests.
  </verify>
  <done>
ConfigurationService skip list behavior for GameType.Unknown is tested (returns only Universal entries). StateService has additional concurrent update edge case tests validating volatile field correctness and event emission. PluginValidationService has tests covering null/whitespace/relative FullPath variants. All TEST-01 through TEST-05 requirements are satisfied.
  </done>
</task>

</tasks>

<verification>
1. `dotnet test AutoQAC.Tests` passes with 0 failures
2. Coverage output exists at AutoQAC.Tests/TestResults/coverage/coverage.cobertura.xml
3. New test count is at least 15 tests higher than the starting ~475
4. LegacyMigrationServiceTests.cs exists as a new file
5. No existing tests were broken or removed (except cmd.exe-spawning tests that were intentionally replaced)
6. ProcessExecutionServiceTests.cs contains NO "cmd.exe" string in executable code (only comments if explaining removal)
</verification>

<success_criteria>
- ProcessExecutionService termination and orphan cleanup tested through mocked IProcessExecutionService -- no real process spawning (TEST-01)
- LegacyMigrationService has 7+ test cases covering all migration paths including failures (TEST-02)
- ConfigurationService GetSkipListAsync with GameType.Unknown is tested (TEST-03)
- StateService has additional concurrent update edge case tests (TEST-04)
- PluginValidationService has tests for null/whitespace/relative FullPath variants (TEST-05)
- Coverlet MSBuild integration produces Cobertura XML on every `dotnet test` run
- All existing tests continue to pass (cmd.exe-spawning tests replaced, not just removed)
</success_criteria>

<output>
After completion, create `.planning/phases/07-hardening-cleanup/07-01-SUMMARY.md`
</output>
