---
phase: 07-hardening-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC.Tests/AutoQAC.Tests.csproj
  - AutoQAC.Tests/Services/ProcessExecutionServiceTests.cs
  - AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs
  - AutoQAC.Tests/Services/ConfigurationServiceSkipListTests.cs
  - AutoQAC.Tests/Services/StateServiceTests.cs
  - AutoQAC.Tests/Services/PluginValidationServiceTests.cs
autonomous: true

must_haves:
  truths:
    - "ProcessExecutionService TerminateProcessAsync and CleanOrphanedProcessesAsync have unit tests covering already-exited, force-kill, grace-period-expired, Win32Exception, and PID-not-found paths"
    - "LegacyMigrationService has tests covering no-legacy-file, C#-config-exists, parse-failure, write-failure, backup-failure, delete-failure, and full-success paths"
    - "ConfigurationService GetSkipListAsync with GameType.Unknown returns only Universal entries (maps to Unknown key which has no match in skip list config)"
    - "StateService concurrent UpdateState calls from multiple tasks produce consistent results"
    - "PluginValidationService has tests for null FullPath, whitespace-only FullPath, and forward-slash relative paths"
    - "Coverlet collects coverage on every dotnet test run via MSBuild properties"
  artifacts:
    - path: "AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs"
      provides: "LegacyMigrationService unit tests"
      min_lines: 100
    - path: "AutoQAC.Tests/AutoQAC.Tests.csproj"
      provides: "Test project with coverlet.msbuild package and coverage MSBuild properties"
      contains: "coverlet.msbuild"
  key_links:
    - from: "AutoQAC.Tests/Services/ProcessExecutionServiceTests.cs"
      to: "AutoQAC/Services/Process/ProcessExecutionService.cs"
      via: "Tests call TerminateProcessAsync and CleanOrphanedProcessesAsync through mocked Process objects"
      pattern: "TerminateProcessAsync|CleanOrphanedProcessesAsync"
    - from: "AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs"
      to: "AutoQAC/Services/Configuration/LegacyMigrationService.cs"
      via: "Tests use temp directory constructor parameter for file system isolation"
      pattern: "LegacyMigrationService.*_testDirectory"
---

<objective>
Fill targeted test coverage gaps for specific requirements TEST-01 through TEST-05, and set up Coverlet MSBuild integration so every `dotnet test` run produces coverage data.

Purpose: The existing test suite has 475+ tests but specific critical paths identified in the requirements lack coverage -- process termination edge cases (TEST-01), migration failure paths (TEST-02), Unknown GameType skip list behavior (TEST-03), concurrent state updates (TEST-04), and non-rooted path validation variants (TEST-05). Coverage tooling setup ensures we can measure progress.

Output: 5 test files modified/created with new test cases, test project csproj updated with Coverlet MSBuild properties, all tests pass with coverage output.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hardening-cleanup/07-CONTEXT.md
@.planning/phases/07-hardening-cleanup/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Coverage tooling setup + ProcessExecutionService and LegacyMigrationService tests</name>
  <files>
    AutoQAC.Tests/AutoQAC.Tests.csproj
    AutoQAC.Tests/Services/ProcessExecutionServiceTests.cs
    AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs
  </files>
  <action>
**Step 1: Coverage tooling setup**

Add `coverlet.msbuild` package to AutoQAC.Tests.csproj alongside existing `coverlet.collector`:
```xml
<PackageReference Include="coverlet.msbuild" Version="6.0.4" />
```

Add MSBuild properties to AutoQAC.Tests.csproj PropertyGroup:
```xml
<CollectCoverage>true</CollectCoverage>
<CoverletOutputFormat>cobertura</CoverletOutputFormat>
<CoverletOutput>./TestResults/coverage/</CoverletOutput>
<Include>[AutoQAC]*</Include>
<Exclude>[AutoQAC.Tests]*</Exclude>
<ExcludeByAttribute>ExcludeFromCodeCoverage</ExcludeByAttribute>
```

Also add `TestResults/` to .gitignore if not already present.

**Step 2: ProcessExecutionService termination unit tests (TEST-01)**

IMPORTANT: Read the current ProcessExecutionServiceTests.cs and ProcessExecutionService.cs first to verify APIs.

The existing tests are all integration tests that spawn real cmd.exe processes. The requirement is to add UNIT tests that test TerminateProcessAsync, CleanOrphanedProcessesAsync, TrackProcessAsync, and UntrackProcessAsync logic without spawning real processes.

Since ProcessExecutionService has hard dependencies on System.Diagnostics.Process (not mockable), the unit tests should focus on:

1. **PID tracking file operations** -- Use temp directories. Create a ProcessExecutionService with mocked IStateService and ILoggingService. Call TrackProcessAsync with a real short-lived Process (start cmd /c exit 0, grab reference before it exits), then verify the JSON file was written with correct PID. Call UntrackProcessAsync and verify PID removed.

2. **CleanOrphanedProcessesAsync with no PID file** -- Verify it returns without error when no PID file exists.

3. **CleanOrphanedProcessesAsync with empty PID file** -- Write empty JSON array to PID file, verify it handles gracefully.

4. **CleanOrphanedProcessesAsync with stale PID entries** -- Write PID file entries with PIDs that don't exist (e.g., PID 99999999). Verify the method handles ArgumentException from GetProcessById gracefully and clears the file.

5. **TerminateProcessAsync with already-exited process** -- Start a process (cmd /c exit 0), wait for it to exit, then call TerminateProcessAsync. Verify it returns TerminationResult.AlreadyExited.

6. **Dispose prevents further execution** -- Already exists but verify it still passes.

Note: ProcessExecutionService constructor takes (IStateService, ILoggingService). The PID file path is resolved internally via GetPidFilePath() which is private and uses AppContext.BaseDirectory. For unit testing PID file operations, the tests need to work with whatever path GetPidFilePath resolves to. Read the implementation carefully -- in DEBUG mode it walks up directories looking for "AutoQAC Data" folder.

**Step 3: LegacyMigrationService tests (TEST-02)**

Create NEW file: AutoQAC.Tests/Services/LegacyMigrationServiceTests.cs

LegacyMigrationService constructor accepts `string? configDirectory` parameter -- use temp directory for isolation. The service reads/writes files named "AutoQAC Config.yaml" (legacy) and "AutoQAC Settings.yaml" (current).

Test cases to implement:

1. **MigrateIfNeeded_NoLegacyFile_ReturnsNotNeeded** -- Empty temp dir, call MigrateIfNeededAsync. Assert Attempted=false, Success=true.

2. **MigrateIfNeeded_CSharpConfigExists_ReturnsNotNeeded** -- Create both legacy and current config files. Call MigrateIfNeededAsync. Assert Attempted=false, Success=true (bootstrap only, no merge).

3. **MigrateIfNeeded_ValidLegacyConfig_MigratesSuccessfully** -- Create only "AutoQAC Config.yaml" with valid YAML content:
   ```yaml
   XEditPath: C:\SSEEdit\SSEEdit.exe
   LoadOrderPath: C:\Users\test\plugins.txt
   ```
   Call MigrateIfNeededAsync. Assert Attempted=true, Success=true, MigratedFiles contains "AutoQAC Config.yaml". Verify "AutoQAC Settings.yaml" was created. Verify backup in migration_backup/ subdirectory. Verify legacy file was deleted.

4. **MigrateIfNeeded_InvalidYaml_ReturnsFailure** -- Create "AutoQAC Config.yaml" with invalid YAML (e.g., `{{{invalid`). Assert Attempted=true, Success=false, FailedFiles contains "AutoQAC Config.yaml".

5. **MigrateIfNeeded_EmptyLegacyFile_ReturnsFailure** -- Create empty "AutoQAC Config.yaml". Assert Attempted=true, Success=false (deserializer returns null).

6. **MigrateIfNeeded_WriteFailure_ReturnsFailure** -- Create valid legacy config. Make the destination path read-only or use a path that will fail. Assert Attempted=true, Success=false. (This is tricky on Windows -- create a directory named "AutoQAC Settings.yaml" to cause write failure, or set read-only attribute on the directory.)

7. **MigrateIfNeeded_BackupFailure_KeepsOriginal** -- Create valid legacy config. Make backup subdirectory path fail (e.g., create a file named "migration_backup" to block directory creation). Assert Attempted=true, Success=false, WarningMessage mentions backup. Verify original legacy file still exists (not deleted since backup failed).

All tests should use `IDisposable` pattern to clean up temp directories.
  </action>
  <verify>
Run `dotnet test AutoQAC.Tests` -- all existing tests plus new tests pass. Verify coverage output appears in AutoQAC.Tests/TestResults/coverage/ directory. Verify LegacyMigrationServiceTests.cs exists and contains at least 7 test methods. Verify ProcessExecutionServiceTests.cs has new unit test methods beyond the existing 7 integration tests.
  </verify>
  <done>
ProcessExecutionService has unit tests for PID tracking, orphan cleanup edge cases, and already-exited termination. LegacyMigrationService has dedicated test file covering all 6 migration paths (no-legacy, C#-exists, valid-migration, invalid-YAML, empty-file, backup-failure). Coverlet MSBuild properties are configured and produce Cobertura XML on every test run.
  </done>
</task>

<task type="auto">
  <name>Task 2: ConfigurationService skip list, StateService concurrent, and PluginValidationService path tests</name>
  <files>
    AutoQAC.Tests/Services/ConfigurationServiceSkipListTests.cs
    AutoQAC.Tests/Services/StateServiceTests.cs
    AutoQAC.Tests/Services/PluginValidationServiceTests.cs
  </files>
  <action>
IMPORTANT: Read ALL three existing test files AND their corresponding service implementations before writing any tests. Verify the exact API signatures of every method being tested.

**Step 1: ConfigurationService skip list with GameType.Unknown (TEST-03)**

Add to existing ConfigurationServiceSkipListTests.cs:

1. **GetSkipListAsync_UnknownGameType_ReturnsOnlyUniversalEntries** -- Set up Main.yaml with:
   ```yaml
   Data:
     SkipLists:
       SSE:
         - Skyrim.esm
       Universal:
         - Update.esm
   ```
   And Settings.yaml with empty SkipLists. Call GetSkipListAsync(GameType.Unknown). The GetGameKey method maps Unknown to "Unknown" string. Since "Unknown" won't match any key in SkipLists, only the Universal entries should be returned. Assert result contains only "Update.esm".

2. **GetSkipListAsync_UnknownGameType_NoUniversal_ReturnsEmpty** -- Set up configs with no Universal key. Call GetSkipListAsync(GameType.Unknown). Assert result is empty.

**Step 2: StateService concurrent edge cases (TEST-04)**

Add to existing StateServiceTests.cs:

1. **ConcurrentUpdateState_RapidToggling_SettlesCorrectly** -- Fire 100 rapid UpdateState calls alternating IsCleaning true/false from Task.Run. After all complete, verify the final state matches the last call's value. Use Task.WhenAll to wait. This tests the volatile _currentState field correctness.

2. **ConcurrentUpdateState_MultiplePropertyUpdates_NoneAreLost** -- From 10 concurrent tasks, each update a different property (e.g., different LoadOrderPath values indexed by task). After all complete, verify the final state has the last writer's value for each property. This validates no torn reads.

3. **StateChanged_RapidUpdates_AllEmitted** -- Subscribe to StateChanged observable, fire 50 rapid UpdateState calls, verify at least 50 emissions were observed (no dropped events from the BehaviorSubject).

Review the StateService API carefully -- it may use UpdateState with an Action<AppState> mutator or separate methods like UpdateConfigurationPaths, SetIsCleaning, etc. Use the actual API.

**Step 3: PluginValidationService non-rooted path variants (TEST-05)**

Add to existing PluginValidationServiceTests.cs:

1. **ValidatePluginFile_NullFullPath_ReturnsNotFound** -- Create PluginInfo with FullPath = null (if nullable) or empty string. Assert NotFound. Note: FullPath is `required string` so test with empty string and whitespace.

2. **ValidatePluginFile_WhitespaceOnlyFullPath_ReturnsNotFound** -- PluginInfo with FullPath = "   ". Assert NotFound.

3. **ValidatePluginFile_ForwardSlashRelativePath_ReturnsNotFound** -- PluginInfo with FullPath = "mods/Skyrim.esm". Assert NotFound (not rooted).

4. **ValidatePluginFile_DotRelativePath_ReturnsNotFound** -- PluginInfo with FullPath = "./plugins/Test.esp". Assert NotFound.

5. **ValidatePluginFile_BackslashRelativePath_ReturnsNotFound** -- PluginInfo with FullPath = "mods\\Skyrim.esm". Assert NotFound.

Read the ValidatePluginFile implementation to confirm it checks IsPathRooted and handles empty/whitespace FullPath. Adjust test expectations if the implementation handles these differently.
  </action>
  <verify>
Run `dotnet test AutoQAC.Tests` -- all tests pass including the new ones. Verify ConfigurationServiceSkipListTests has Unknown GameType tests. Verify StateServiceTests has new concurrent edge case tests. Verify PluginValidationServiceTests has 4+ new non-rooted path variant tests.
  </verify>
  <done>
ConfigurationService skip list behavior for GameType.Unknown is tested (returns only Universal entries). StateService has additional concurrent update edge case tests validating volatile field correctness and event emission. PluginValidationService has tests covering null/whitespace/relative FullPath variants. All TEST-01 through TEST-05 requirements are satisfied.
  </done>
</task>

</tasks>

<verification>
1. `dotnet test AutoQAC.Tests` passes with 0 failures
2. Coverage output exists at AutoQAC.Tests/TestResults/coverage/coverage.cobertura.xml
3. New test count is at least 20 tests higher than the starting ~475
4. LegacyMigrationServiceTests.cs exists as a new file
5. No existing tests were broken or removed
</verification>

<success_criteria>
- ProcessExecutionService has unit tests for TerminateProcessAsync edge cases and PID tracking (TEST-01)
- LegacyMigrationService has 7+ test cases covering all migration paths including failures (TEST-02)
- ConfigurationService GetSkipListAsync with GameType.Unknown is tested (TEST-03)
- StateService has additional concurrent update edge case tests (TEST-04)
- PluginValidationService has tests for null/whitespace/relative FullPath variants (TEST-05)
- Coverlet MSBuild integration produces Cobertura XML on every `dotnet test` run
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-hardening-cleanup/07-01-SUMMARY.md`
</output>
