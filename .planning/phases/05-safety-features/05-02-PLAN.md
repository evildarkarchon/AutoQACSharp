---
phase: 05-safety-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Models/Configuration/BackupSettings.cs
  - AutoQAC/Models/BackupSession.cs
  - AutoQAC/Models/BackupResult.cs
  - AutoQAC/Services/Backup/IBackupService.cs
  - AutoQAC/Services/Backup/BackupService.cs
  - AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/Models/Configuration/UserConfiguration.cs
  - AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  - AutoQAC/ViewModels/RestoreViewModel.cs
  - AutoQAC/ViewModels/MainWindowViewModel.cs
  - AutoQAC/ViewModels/SettingsViewModel.cs
  - AutoQAC/Views/RestoreWindow.axaml
  - AutoQAC/Views/RestoreWindow.axaml.cs
  - AutoQAC/Views/MainWindow.axaml
  - AutoQAC/Views/SettingsWindow.axaml
autonomous: false

must_haves:
  truths:
    - "When backup is enabled, each plugin is copied to a timestamped backup directory before xEdit processes it"
    - "If backup copy fails, a dialog asks the user to skip, abort, or continue without backup"
    - "User can browse previous backup sessions from the main window via 'Restore Backups' button"
    - "User can drill into a session to see individual plugins and restore them"
    - "Restore All requires confirmation dialog; individual plugin restore does not"
    - "Backup enable/disable toggle and retention count appear in Settings"
    - "Backup is enabled by default for new users"
    - "MO2 mode silently skips backup with a log warning"
  artifacts:
    - path: "AutoQAC/Models/Configuration/BackupSettings.cs"
      provides: "BackupSettings class with Enabled and MaxSessions"
      contains: "BackupSettings"
    - path: "AutoQAC/Models/BackupSession.cs"
      provides: "BackupSession record, BackupPluginEntry record"
      contains: "BackupSession"
    - path: "AutoQAC/Models/BackupResult.cs"
      provides: "BackupResult class and BackupFailureChoice enum"
      contains: "BackupFailureChoice"
    - path: "AutoQAC/Services/Backup/IBackupService.cs"
      provides: "Backup service interface"
      exports: ["IBackupService"]
    - path: "AutoQAC/Services/Backup/BackupService.cs"
      provides: "Backup, restore, retention, and session enumeration"
      contains: "BackupService"
    - path: "AutoQAC/ViewModels/RestoreViewModel.cs"
      provides: "Two-level backup browser ViewModel"
      contains: "RestoreViewModel"
    - path: "AutoQAC/Views/RestoreWindow.axaml"
      provides: "Backup restore browser UI"
      contains: "RestoreWindow"
  key_links:
    - from: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      to: "AutoQAC/Services/Backup/IBackupService.cs"
      via: "BackupPluginAsync call before CleanPluginAsync in per-plugin loop"
      pattern: "BackupPluginAsync"
    - from: "AutoQAC/ViewModels/MainWindowViewModel.cs"
      to: "AutoQAC/ViewModels/RestoreViewModel.cs"
      via: "ShowRestoreInteraction opening RestoreWindow"
      pattern: "ShowRestoreInteraction"
    - from: "AutoQAC/Models/Configuration/UserConfiguration.cs"
      to: "AutoQAC/Models/Configuration/BackupSettings.cs"
      via: "Backup property on UserConfiguration"
      pattern: "BackupSettings"
---

<objective>
Add plugin backup before cleaning with failure dialog, backup restore browser, and backup settings in the Settings window.

Purpose: Users have a safety net -- every plugin is backed up before xEdit touches it, and they can restore any previous backup if something goes wrong.
Output: BackupService for file backup/restore, CleaningOrchestrator integration, RestoreWindow with two-level browser, Settings backup section.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-safety-features/05-RESEARCH.md

@AutoQAC/Models/PluginInfo.cs
@AutoQAC/Models/AppState.cs
@AutoQAC/Models/Configuration/UserConfiguration.cs
@AutoQAC/Models/Configuration/RetentionSettings.cs
@AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/ViewModels/MainWindowViewModel.cs
@AutoQAC/ViewModels/SettingsViewModel.cs
@AutoQAC/Views/MainWindow.axaml
@AutoQAC/Views/SettingsWindow.axaml
@AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: BackupService, models, orchestrator integration, and DI wiring</name>
  <files>
    AutoQAC/Models/Configuration/BackupSettings.cs
    AutoQAC/Models/BackupSession.cs
    AutoQAC/Models/BackupResult.cs
    AutoQAC/Services/Backup/IBackupService.cs
    AutoQAC/Services/Backup/BackupService.cs
    AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
    AutoQAC/Models/Configuration/UserConfiguration.cs
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  </files>
  <action>
1. **Create `AutoQAC/Models/Configuration/BackupSettings.cs`:**
   ```csharp
   namespace AutoQAC.Models.Configuration;
   public sealed class BackupSettings
   {
       [YamlMember(Alias = "enabled")]
       public bool Enabled { get; set; } = true; // Enabled by default per user decision

       [YamlMember(Alias = "max_sessions")]
       public int MaxSessions { get; set; } = 10; // Default: 10 sessions (Claude's discretion)
   }
   ```

2. **Create `AutoQAC/Models/BackupResult.cs`:**
   - `BackupResult` class with static factory methods:
     - `static BackupResult Ok(long fileSizeBytes)` -- success with file size
     - `static BackupResult Failure(string error)` -- failure with error message
     - Properties: `bool Success`, `long FileSizeBytes`, `string? Error`
   - `BackupFailureChoice` enum: `SkipPlugin`, `AbortSession`, `ContinueWithoutBackup`
   - `BackupFailureCallback` delegate: `Task<BackupFailureChoice> BackupFailureCallback(string pluginName, string errorMessage)`

3. **Create `AutoQAC/Models/BackupSession.cs`:**
   - `BackupSession` sealed record:
     - `DateTime Timestamp { get; init; }`
     - `string GameType { get; init; }`
     - `string SessionDirectory { get; init; }` -- absolute path to session dir (not serialized, populated at load time)
     - `List<BackupPluginEntry> Plugins { get; init; }`
   - `BackupPluginEntry` sealed record:
     - `string FileName { get; init; }`
     - `string OriginalPath { get; init; }` -- absolute path where plugin was before backup
     - `long FileSizeBytes { get; init; }`
   - Use `System.Text.Json` attributes for JSON serialization (session.json sidecar)
   - Mark `SessionDirectory` with `[JsonIgnore]` since it is derived from the filesystem path, not stored in JSON

4. **Create `AutoQAC/Services/Backup/IBackupService.cs`:**
   ```csharp
   public interface IBackupService
   {
       /// <summary>Creates a new session directory and returns its path. Format: yyyy-MM-dd_HH-mm-ss</summary>
       string CreateSessionDirectory(string backupRoot);

       /// <summary>Copies the plugin file to the session directory.</summary>
       BackupResult BackupPlugin(PluginInfo plugin, string sessionDir);

       /// <summary>Writes session.json metadata sidecar to the session directory.</summary>
       Task WriteSessionMetadataAsync(string sessionDir, BackupSession session, CancellationToken ct = default);

       /// <summary>Enumerates all backup sessions from the backup root, newest first.</summary>
       Task<List<BackupSession>> GetBackupSessionsAsync(string backupRoot, CancellationToken ct = default);

       /// <summary>Restores a single plugin from backup to its original path.</summary>
       void RestorePlugin(BackupPluginEntry entry, string sessionDir);

       /// <summary>Restores all plugins from a session.</summary>
       void RestoreSession(BackupSession session);

       /// <summary>Deletes oldest sessions beyond maxSessionCount. Never deletes currentSessionDir.</summary>
       void CleanupOldSessions(string backupRoot, int maxSessionCount, string? currentSessionDir = null);

       /// <summary>Resolves backup root path from game Data folder. Returns "[GameDir]/AutoQAC Backups".</summary>
       string GetBackupRoot(string dataFolderPath);
   }
   ```

5. **Implement `AutoQAC/Services/Backup/BackupService.cs`:**
   - Constructor takes `ILoggingService`
   - `CreateSessionDirectory`: `Path.Combine(backupRoot, DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"))`, call `Directory.CreateDirectory`
   - `BackupPlugin`:
     - Guard: if `plugin.FullPath` is null/empty or not rooted, return Failure
     - Guard: if source file does not exist, return Failure
     - Ensure session dir exists (Directory.CreateDirectory is idempotent)
     - `File.Copy(sourcePath, destPath, overwrite: false)` -- catch IOException (already exists), UnauthorizedAccessException, general IOException
     - Return Ok with file size from `new FileInfo(destPath).Length`
   - `WriteSessionMetadataAsync`: serialize `BackupSession` to `session.json` in sessionDir using `JsonSerializer.SerializeAsync` with `WriteIndented = true`
   - `GetBackupSessionsAsync`:
     - Enumerate `Directory.GetDirectories(backupRoot)`, sorted descending (newest first by name, which is by timestamp)
     - For each directory containing `session.json`, deserialize and populate `SessionDirectory` from the filesystem path
     - Skip directories without session.json or with corrupt JSON (catch JsonException, log warning)
   - `RestorePlugin`: `File.Copy(backupPath, entry.OriginalPath, overwrite: true)`. Throw `FileNotFoundException` if backup file missing.
   - `RestoreSession`: iterate session.Plugins, call RestorePlugin for each
   - `CleanupOldSessions`:
     - Get all session dirs sorted descending (newest first)
     - Skip first `maxSessionCount` entries AND skip `currentSessionDir` if provided
     - Delete remaining with `Directory.Delete(dir, recursive: true)`, catch exceptions and log warning
   - `GetBackupRoot`: `Path.Combine(Path.GetDirectoryName(dataFolderPath)!, "AutoQAC Backups")`

6. **Update `AutoQAC/Models/Configuration/UserConfiguration.cs`:**
   - Add property:
     ```csharp
     [YamlMember(Alias = "Backup")]
     public BackupSettings Backup { get; set; } = new();
     ```
   - Add required `using AutoQAC.Models.Configuration;` if not already present

7. **Update `ICleaningOrchestrator`:**
   - Add overload: `Task StartCleaningAsync(TimeoutRetryCallback? onTimeout, BackupFailureCallback? onBackupFailure, CancellationToken ct = default);`
   - Keep the existing 2-param overload (onTimeout + ct) delegating to the new 3-param one with onBackupFailure=null

8. **Update `CleaningOrchestrator`:**
   - Add `IBackupService _backupService` and `IConfigurationService _configService` (configService already exists) to constructor. Add IBackupService parameter.
   - In `StartCleaningAsync` (the main implementation), add backup logic INSIDE the per-plugin foreach loop, BEFORE `_cleaningService.CleanPluginAsync`:
     ```
     // Backup logic -- right before xEdit processes this plugin
     var backupEnabled = userConfig.Backup.Enabled;
     var isMo2Mode = userConfig.Settings.Mo2Mode;

     if (backupEnabled && !isMo2Mode)
     {
         var backupResult = _backupService.BackupPlugin(plugin, sessionDir);
         if (!backupResult.Success)
         {
             if (onBackupFailure != null)
             {
                 var choice = await onBackupFailure(plugin.FileName, backupResult.Error!);
                 switch (choice)
                 {
                     case BackupFailureChoice.SkipPlugin:
                         // Add to skipped, continue to next plugin
                         continue;
                     case BackupFailureChoice.AbortSession:
                         // Write partial metadata, return
                         return;
                     case BackupFailureChoice.ContinueWithoutBackup:
                         break; // Proceed without backup
                 }
             }
             else
             {
                 _logger.Warning("Backup failed for {Plugin}: {Error}. No callback, continuing without backup.", plugin.FileName, backupResult.Error);
             }
         }
         else
         {
             backupEntries.Add(new BackupPluginEntry { ... });
         }
     }
     else if (backupEnabled && isMo2Mode)
     {
         _logger.Warning("Backup skipped in MO2 mode for {Plugin} -- MO2 manages files through its virtual filesystem", plugin.FileName);
     }
     ```
   - Before the per-plugin loop: resolve backup root from data folder path, create session directory, initialize `List<BackupPluginEntry> backupEntries`
   - After the per-plugin loop (in the success path AND the OperationCanceledException path): write session metadata via `_backupService.WriteSessionMetadataAsync` if any backups were made, then run retention cleanup
   - The data folder path comes from the game's data folder. Get it from `_pluginLoadingService` or from config. Check how GameDataFolder is resolved -- look at MainWindowViewModel.GameDataFolder. For the orchestrator, the data folder can be derived from the first plugin's FullPath: `Path.GetDirectoryName(pluginsToClean[0].FullPath)`. This is the Data directory. Use this to compute backup root.
     ALTERNATIVE (simpler): Get the data folder from config via `_configService.GetGameDataFolderOverrideAsync` or from `_gameDetectionService`. Actually, simplest approach: derive from the first valid plugin's FullPath directory. The plugins have already been validated to have rooted FullPaths at this point.
   - Guard: if no plugins have rooted FullPaths (all MO2 mode), skip backup initialization entirely.

9. **Update `ServiceCollectionExtensions.cs`:**
   - In `AddBusinessLogic()`, add: `services.AddSingleton<IBackupService, BackupService>();`

IMPORTANT: When adding the IBackupService parameter to CleaningOrchestrator's constructor, also update any test mocks that construct CleaningOrchestrator (check test project). Verify the constructor parameter list by reading CleaningOrchestrator's current constructor. Add the new parameter at the end.

IMPORTANT: The 2-param StartCleaningAsync(onTimeout, ct) must delegate to the new 3-param version with onBackupFailure: null. The existing 1-param version StartCleaningAsync(ct) already delegates to 2-param, so the chain is: 1-param -> 2-param -> 3-param.
  </action>
  <verify>
    `dotnet build` succeeds. `dotnet test` passes (after updating any mocks that construct CleaningOrchestrator with the new IBackupService parameter). Inspect that CleaningOrchestrator calls BackupPlugin before CleanPluginAsync in the per-plugin loop.
  </verify>
  <done>
    BackupService creates timestamped session directories, copies plugin files before xEdit processes them, writes session.json metadata, supports restore and retention cleanup. Backup is integrated into the cleaning pipeline with failure callback support. MO2 mode silently skips backup. BackupSettings added to UserConfiguration with enabled=true and maxSessions=10 defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: RestoreWindow, Settings backup section, MainWindow buttons, and callback wiring</name>
  <files>
    AutoQAC/ViewModels/RestoreViewModel.cs
    AutoQAC/ViewModels/MainWindowViewModel.cs
    AutoQAC/ViewModels/SettingsViewModel.cs
    AutoQAC/Views/RestoreWindow.axaml
    AutoQAC/Views/RestoreWindow.axaml.cs
    AutoQAC/Views/MainWindow.axaml
    AutoQAC/Views/SettingsWindow.axaml
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  </files>
  <action>
1. **Create `AutoQAC/ViewModels/RestoreViewModel.cs`:**
   - Inherits ViewModelBase, implements IDisposable
   - Constructor takes `IBackupService backupService`, `IConfigurationService configService`, `IMessageDialogService messageDialog`, `ILoggingService logger`
   - Properties:
     - `ObservableCollection<BackupSession> Sessions` -- the list of backup sessions
     - `BackupSession? SelectedSession` -- currently selected session (first level)
     - `ObservableCollection<BackupPluginEntry> SelectedSessionPlugins` -- plugins in selected session (second level)
     - `BackupPluginEntry? SelectedPlugin` -- currently selected plugin in drill-down
     - `bool IsLoading`
     - `string StatusText`
     - `bool HasSessions` -- computed from Sessions.Count > 0
   - Commands:
     - `ReactiveCommand<Unit, Unit> LoadSessionsCommand` -- calls LoadSessionsAsync
     - `ReactiveCommand<Unit, Unit> RestorePluginCommand` -- enabled when SelectedPlugin != null, calls RestorePluginAsync
     - `ReactiveCommand<Unit, Unit> RestoreAllCommand` -- enabled when SelectedSession != null, calls RestoreAllAsync
     - `ReactiveCommand<Unit, Unit> DeleteSessionCommand` -- enabled when SelectedSession != null, deletes session directory
     - `ReactiveCommand<Unit, Unit> CloseCommand` -- raises CloseRequested event
   - Event: `EventHandler? CloseRequested`
   - `LoadSessionsAsync`:
     - Get backup root from current game's data folder (resolve from config/state)
     - Call `_backupService.GetBackupSessionsAsync(backupRoot)`
     - Populate Sessions collection
   - `RestorePluginAsync`:
     - Call `_backupService.RestorePlugin(SelectedPlugin, SelectedSession.SessionDirectory)`
     - On success: StatusText = "Restored [plugin name]"
     - On failure: show error dialog via _messageDialog
     - No confirmation dialog (per user decision: individual restores proceed without confirmation)
   - `RestoreAllAsync`:
     - Show confirmation dialog: "Restore all N plugins from session [date]? This will overwrite current files."
     - If confirmed: call `_backupService.RestoreSession(SelectedSession)` wrapped in try/catch
     - On success: StatusText = "Restored all N plugins"
     - On partial failure: show error dialog listing which plugins failed
   - When `SelectedSession` changes, populate `SelectedSessionPlugins` from session.Plugins
   - The backup root needs the game's Data folder path. Get this by:
     - Reading UserConfiguration to get selected game
     - Using IPluginLoadingService.GetGameDataFolder or reading from AppState
     - SIMPLEST: Accept `string? dataFolderPath` in constructor or as a method parameter in LoadSessionsAsync
     - Actually: pass it as a parameter when creating the ViewModel. MainWindowViewModel knows the GameDataFolder.

2. **Create `AutoQAC/Views/RestoreWindow.axaml`:**
   - Window: Title="Restore Backups", Width=700, Height=500, CanResize=True
   - x:DataType="vm:RestoreViewModel"
   - Two-panel layout using Grid with ColumnDefinitions="250,*":
     - Left panel: "Backup Sessions" header + ListBox bound to Sessions
       - ItemTemplate: show session timestamp (formatted nicely, e.g., "Feb 7, 2026 2:30 PM") and plugin count ("4 plugins")
       - SelectedItem bound to SelectedSession
     - Right panel: "Session Details" header + ListBox bound to SelectedSessionPlugins
       - ItemTemplate: show FileName and file size (formatted, e.g., "1.2 MB")
       - SelectedItem bound to SelectedPlugin
       - Empty state: "Select a session to view plugins"
   - Bottom button bar:
     - "Restore Selected" button (Command=RestorePluginCommand), enabled when SelectedPlugin != null
     - "Restore All" button (Command=RestoreAllCommand), enabled when SelectedSession != null
     - "Delete Session" button (Command=DeleteSessionCommand), on the left side
     - "Close" button (Command=CloseCommand), on the right side
   - Status bar at bottom with StatusText

3. **Create `AutoQAC/Views/RestoreWindow.axaml.cs`:**
   - Standard code-behind: InitializeComponent()
   - Subscribe to CloseRequested event to close window (same pattern as ProgressWindow)
   - Override OnOpened to call LoadSessionsCommand.Execute()

4. **Update `MainWindowViewModel`:**
   - Add `Interaction<Unit, Unit> ShowRestoreInteraction`
   - Add `ReactiveCommand<Unit, Unit> RestoreBackupsCommand`
   - Wire RestoreBackupsCommand in constructor -- enabled when NOT cleaning
   - Handler `ShowRestoreAsync`: `await ShowRestoreInteraction.Handle(Unit.Default)`
   - Wire `BackupFailureCallback` in `StartCleaningAsync`:
     - Change the call from `_orchestrator.StartCleaningAsync(HandleTimeoutRetryAsync)` to `_orchestrator.StartCleaningAsync(HandleTimeoutRetryAsync, HandleBackupFailureAsync)`
     - Implement `HandleBackupFailureAsync(string pluginName, string errorMessage)`:
       - Show a dialog via _messageDialog with three buttons: "Skip Plugin", "Abort Session", "Continue Without Backup"
       - Return the appropriate BackupFailureChoice
       - Use _messageDialog.ShowCustomAsync or build a custom dialog. Actually, the existing MessageDialogService may not support 3-button dialogs. Check IMessageDialogService.
       - SIMPLEST approach: Use IMessageDialogService.ShowRetryAsync pattern but with custom messaging, or create a simple helper that shows a message dialog. Since the dialog service returns bool (retry=true/false), we need a 3-choice dialog.
       - Create a new method on IMessageDialogService: `Task<BackupFailureChoice> ShowBackupFailureAsync(string pluginName, string errorMessage)`
       - Or: implement using a sequence of two dialogs (not ideal) -- actually, just extend MessageDialogService.
       - RECOMMENDATION: Add `ShowBackupFailureDialogAsync` to IMessageDialogService and MessageDialogService that shows a custom 3-button dialog. Use Avalonia's TaskDialog or build a simple custom dialog. For MVP, a simple approach: show a dialog with message and 3 buttons via a new method.

5. **Update `IMessageDialogService` and `MessageDialogService`:**
   - Add: `Task<BackupFailureChoice> ShowBackupFailureDialogAsync(string pluginName, string errorMessage);`
   - Implementation: Create a Window with the error message and three buttons (Skip Plugin, Abort Session, Continue Without Backup). Show as dialog, return the choice.
   - Each button sets the result and closes the dialog.

6. **Update `MainWindow.axaml.cs`:**
   - Register handler for ShowRestoreInteraction
   - Handler: resolve RestoreViewModel (pass GameDataFolder), create RestoreWindow, set DataContext, show as modal dialog

7. **Update `MainWindow.axaml`:**
   - Add "Restore Backups" button in the control buttons area (Grid.Row="3")
   - Place it on the LEFT side of the button bar (before Preview and Start Cleaning which are right-aligned)
   - Command: `{Binding RestoreBackupsCommand}`
   - Enabled when NOT cleaning

8. **Update `SettingsViewModel`:**
   - Add properties: `bool BackupEnabled`, `int BackupMaxSessions`
   - Add originals: `_originalBackupEnabled`, `_originalBackupMaxSessions`
   - In `LoadSettingsAsync`: load from `config.Backup.Enabled` and `config.Backup.MaxSessions`
   - In `SaveAsync`: save to `config.Backup.Enabled` and `config.Backup.MaxSessions`
   - In `ResetToDefaults`: reset to BackupSettings defaults (enabled=true, maxSessions=10)
   - Add BackupMaxSessions validation: must be >= 1 and <= 100
   - Add to unsaved changes tracking (include in _hasUnsavedChanges CombineLatest)
   - Add to aggregate validation

9. **Update `SettingsWindow.axaml`:**
   - Add a "Backup" section between "Log Retention" and "Cleaning Settings" (or after Cleaning Settings, before Mode Settings):
     - Header: "Plugin Backup" (FontSize 14, SemiBold)
     - CheckBox: "Enable plugin backup before cleaning" bound to BackupEnabled
     - Subtitle text (when enabled): "Plugins are backed up to a folder next to the game's Data directory"
     - NumericUpDown: "Sessions to keep:" bound to BackupMaxSessions, Minimum=1, Maximum=100, Increment=1
     - Note: show "Backup is unavailable in MO2 mode" text when Mo2Mode is true (bind to Mo2Mode property)
   - Add Separator before and after the backup section

10. **Register RestoreViewModel and RestoreWindow in `ServiceCollectionExtensions.cs`:**
    - In AddViewModels: `services.AddTransient<RestoreViewModel>();`
    - In AddViews: `services.AddTransient<RestoreWindow>();`

IMPORTANT: When adding BackupFailureCallback to the orchestrator call chain, ensure the existing 1-param and 2-param StartCleaningAsync overloads still compile and work. The 2-param overload should delegate to 3-param with onBackupFailure: null. Do NOT break the test project.

IMPORTANT: The Restore window must pass the game's data folder path to the ViewModel so it can resolve the backup root. The simplest approach: RestoreViewModel.LoadSessionsAsync(string dataFolderPath) takes it as a parameter, or set it as a property before calling LoadSessions.
  </action>
  <verify>
    `dotnet build` succeeds. `dotnet test` passes. Inspect MainWindow.axaml has "Restore Backups" button. Inspect SettingsWindow.axaml has backup section. Inspect RestoreWindow.axaml has two-panel layout. Inspect MainWindowViewModel wires BackupFailureCallback.
  </verify>
  <done>
    Restore Backups button on main window opens a two-level browser showing sessions and their plugins. Individual and session-wide restore works. Settings window has backup enable/disable toggle and retention count. Backup failure during cleaning shows a 3-choice dialog. MO2 mode backup note shown in settings.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Safety Features phase:
    1. Dry-run preview mode (Preview button, progress window preview panel, per-plugin Will Clean/Will Skip results)
    2. Plugin backup before cleaning (timestamped session directories, per-plugin backup before xEdit)
    3. Backup restore browser (two-level session/plugin browser, individual and Restore All)
    4. Backup settings in Settings window (enable/disable, retention count)
    5. Backup failure dialog (skip/abort/continue)
  </what-built>
  <how-to-verify>
    1. Launch the application (`dotnet run --project AutoQAC`)
    2. Configure a game with plugins (select game, ensure xEdit path is set)
    3. Click "Preview" button -- verify:
       - Progress window opens with "Dry-Run Preview" header
       - Disclaimer banner shows "Preview only -- does not detect ITMs/UDRs"
       - Each plugin shows "Will clean" (green) or "Will skip: [reason]" (orange)
       - No counter badges (ITM/UDR/Nav), no Stop button
       - Close button works
    4. Open Settings -- verify:
       - "Plugin Backup" section appears with enable checkbox and session count
       - Backup is enabled by default
       - Save and reopen to confirm persistence
    5. Click "Start Cleaning" with backup enabled -- verify:
       - Plugins are backed up to [GameDir]/AutoQAC Backups/[timestamp]/
       - session.json exists in the backup directory
       - Cleaning proceeds normally after backup
    6. Click "Restore Backups" -- verify:
       - Left panel shows backup sessions (date + plugin count)
       - Clicking a session shows its plugins in the right panel
       - "Restore Selected" restores a single plugin without confirmation
       - "Restore All" shows confirmation dialog before proceeding
    7. Close and verify all changes persist
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build` completes without errors
2. `dotnet test` passes (all 472+ existing tests)
3. BackupService creates timestamped directories and copies files
4. CleaningOrchestrator calls BackupPlugin before CleanPluginAsync
5. BackupFailureCallback surfaces 3-choice dialog to user
6. RestoreWindow shows two-level session/plugin browser
7. Settings has backup enable/disable and retention count
8. UserConfiguration serializes/deserializes BackupSettings in YAML
9. MO2 mode logs warning and skips backup
10. Backup retention cleanup runs after session completes
</verification>

<success_criteria>
- Plugins are backed up individually before xEdit processes each one
- Backup failure shows skip/abort/continue dialog
- Users can browse and restore from previous backup sessions
- Backup settings are configurable and persist to config
- MO2 mode gracefully skips backup with log warning
- Build and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-safety-features/05-02-SUMMARY.md`
</output>
