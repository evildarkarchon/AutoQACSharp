---
phase: 05-safety-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Models/DryRunResult.cs
  - AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/ViewModels/ProgressViewModel.cs
  - AutoQAC/ViewModels/MainWindowViewModel.cs
  - AutoQAC/Views/ProgressWindow.axaml
  - AutoQAC/Views/MainWindow.axaml
autonomous: true

must_haves:
  truths:
    - "User can click a Preview button on the main window to run a dry-run"
    - "Dry-run shows each plugin as 'Will clean' or 'Will skip: [reason]' without invoking xEdit"
    - "Dry-run results display in the existing progress window with a 'Preview' banner"
    - "A disclaimer is shown: 'Preview only -- does not detect ITMs/UDRs (requires xEdit)'"
    - "Counter badges (ITM/UDR/Nav) and Stop button are hidden in preview mode"
  artifacts:
    - path: "AutoQAC/Models/DryRunResult.cs"
      provides: "DryRunResult record and DryRunStatus enum"
      contains: "DryRunStatus"
    - path: "AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs"
      provides: "RunDryRunAsync method signature"
      contains: "RunDryRunAsync"
    - path: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      provides: "RunDryRunAsync implementation reusing validation pipeline"
      contains: "RunDryRunAsync"
    - path: "AutoQAC/ViewModels/ProgressViewModel.cs"
      provides: "IsPreviewMode flag and DryRunResults collection"
      contains: "IsPreviewMode"
    - path: "AutoQAC/ViewModels/MainWindowViewModel.cs"
      provides: "PreviewCommand wired to orchestrator"
      contains: "PreviewCommand"
  key_links:
    - from: "AutoQAC/ViewModels/MainWindowViewModel.cs"
      to: "ICleaningOrchestrator.RunDryRunAsync"
      via: "PreviewCommand calling RunDryRunAsync"
      pattern: "RunDryRunAsync"
    - from: "AutoQAC/ViewModels/ProgressViewModel.cs"
      to: "AutoQAC/Models/DryRunResult.cs"
      via: "DryRunResults ObservableCollection"
      pattern: "DryRunResult"
    - from: "AutoQAC/Views/ProgressWindow.axaml"
      to: "AutoQAC/ViewModels/ProgressViewModel.cs"
      via: "IsPreviewMode binding toggling UI panels"
      pattern: "IsPreviewMode"
---

<objective>
Add dry-run preview mode that shows which plugins would be cleaned or skipped (and why) without invoking xEdit.

Purpose: Users can verify their configuration and skip list before committing to a cleaning session, building trust in the tool.
Output: DryRunResult model, RunDryRunAsync on orchestrator, Preview button on main window, preview mode in progress window.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-safety-features/05-RESEARCH.md

@AutoQAC/Models/PluginInfo.cs
@AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/ViewModels/ProgressViewModel.cs
@AutoQAC/ViewModels/MainWindowViewModel.cs
@AutoQAC/Views/ProgressWindow.axaml
@AutoQAC/Views/ProgressWindow.axaml.cs
@AutoQAC/Views/MainWindow.axaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: DryRunResult model and RunDryRunAsync orchestrator method</name>
  <files>
    AutoQAC/Models/DryRunResult.cs
    AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  </files>
  <action>
1. Create `AutoQAC/Models/DryRunResult.cs`:
   - `DryRunStatus` enum with two values: `WillClean`, `WillSkip`
   - `DryRunResult` sealed record with properties: `string PluginName`, `DryRunStatus Status`, `string Reason`
   - Namespace: `AutoQAC.Models`

2. Add to `ICleaningOrchestrator`:
   - New method: `Task<List<DryRunResult>> RunDryRunAsync(CancellationToken ct = default);`
   - XML doc: "Runs validation pipeline without invoking xEdit. Returns a preview of which plugins would be cleaned or skipped."

3. Implement `RunDryRunAsync` in `CleaningOrchestrator`:
   - Reuse the SAME validation pipeline as StartCleaningAsync (steps 1-4b) but WITHOUT starting xEdit, WITHOUT updating state, WITHOUT creating CTS.
   - Step-by-step for each plugin in state.PluginsToClean:
     a. If plugin is NOT selected: add WillSkip "Not selected"
     b. If game type is Unknown: throw InvalidOperationException (same as StartCleaningAsync)
     c. Apply skip list filtering (same logic as steps 3b-4): if IsInSkipList, add WillSkip "In skip list"
     d. Apply file-existence validation (step 4b, skip in MO2 mode): if ValidatePluginFile returns non-None PluginWarningKind, add WillSkip with reason (e.g., "File not found", "Zero-byte file", etc.)
     e. Otherwise: add WillClean "Ready for cleaning"
   - The method must call `_configService.FlushPendingSavesAsync` at the start (same as StartCleaningAsync) to ensure config is current.
   - The method must NOT call `_stateService.StartCleaning`, `_stateService.FinishCleaningWithResults`, or any state mutation.
   - The method must NOT create or manage any CancellationTokenSource (use the passed ct directly).
   - The method must NOT clean any orphaned processes.
   - Detect game type the same way as StartCleaningAsync (from executable or load order), but store result locally -- do NOT update state.

IMPORTANT: Extract the shared validation logic conceptually but do NOT refactor StartCleaningAsync. The dry-run method duplicates the relevant validation steps. This keeps the change minimal and avoids risking the working cleaning pipeline.
  </action>
  <verify>
    `dotnet build` succeeds. Inspect that ICleaningOrchestrator has RunDryRunAsync. Inspect that CleaningOrchestrator.RunDryRunAsync produces DryRunResult list with correct skip reasons.
  </verify>
  <done>
    RunDryRunAsync returns a List of DryRunResult where each plugin is categorized as WillClean or WillSkip with a human-readable reason. No xEdit process is launched. No state is mutated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Preview mode in ProgressViewModel, PreviewCommand in MainWindowViewModel, UI updates</name>
  <files>
    AutoQAC/ViewModels/ProgressViewModel.cs
    AutoQAC/ViewModels/MainWindowViewModel.cs
    AutoQAC/Views/ProgressWindow.axaml
    AutoQAC/Views/MainWindow.axaml
  </files>
  <action>
1. **ProgressViewModel additions:**
   - Add `bool IsPreviewMode` property with RaiseAndSetIfChanged
   - Add `ObservableCollection<DryRunResult> DryRunResults` property (for displaying preview items)
   - Add `string PreviewDisclaimer` readonly property returning "Preview only -- does not detect ITMs/UDRs (requires xEdit)"
   - Add `int WillCleanCount` and `int WillSkipCount` computed properties (derived from DryRunResults)
   - Add a `LoadDryRunResults(List<DryRunResult> results)` method that:
     - Sets IsPreviewMode = true
     - Clears and populates DryRunResults
     - Computes WillCleanCount and WillSkipCount
     - Sets IsShowingResults = true (reuses the results panel layout concept)
   - Modify ResetForNewSession to also reset IsPreviewMode = false and clear DryRunResults
   - The CloseCommand should already work (raises CloseRequested)

2. **MainWindowViewModel additions:**
   - Add `ReactiveCommand<Unit, Unit> PreviewCommand` property
   - Wire PreviewCommand in constructor:
     - Use same `canStart` observable as StartCleaningCommand (requires plugins + xEdit path + not cleaning)
     - Handler: `RunPreviewAsync` method
   - Implement `RunPreviewAsync`:
     - Clear validation errors (same as StartCleaningAsync)
     - Run ValidatePreClean() -- if errors, show inline panel and return (same as StartCleaningAsync)
     - Call `var results = await _orchestrator.RunDryRunAsync()`
     - Create a new ProgressViewModel manually (resolve from DI or construct -- check how ProgressWindow gets its ViewModel)
       Actually, looking at the codebase: the ShowProgressInteraction is used to show the window. For preview, we need a slightly different flow:
     - Add a new `Interaction<List<DryRunResult>, Unit> ShowPreviewInteraction`
     - Call `_ = ShowPreviewInteraction.Handle(results)` to show the preview window
     - In `MainWindow.axaml.cs`, register handler for ShowPreviewInteraction that:
       - Resolves a ProgressViewModel from DI
       - Calls viewModel.LoadDryRunResults(results)
       - Creates ProgressWindow, sets DataContext, shows it non-modal
   - Catch InvalidOperationException (same pattern as StartCleaningAsync for config errors)
   - Catch generic Exception (same pattern)

3. **MainWindow.axaml.cs updates:**
   - Register handler for ShowPreviewInteraction alongside the existing ShowProgressInteraction handler
   - The handler should create ProgressWindow, resolve ProgressViewModel, call LoadDryRunResults, and show non-modal

4. **MainWindow.axaml updates:**
   - Add a "Preview" button next to the existing "Start Cleaning" button in the control buttons panel (Grid.Row="3")
   - Button text: "Preview"
   - Command: `{Binding PreviewCommand}`
   - ToolTip: "Preview which plugins will be cleaned or skipped (without running xEdit)"
   - Place it BEFORE "Start Cleaning" to keep it visually accessible but secondary

5. **ProgressWindow.axaml updates:**
   Add a THIRD panel (alongside the active cleaning panel and results panel) for preview mode. This panel is shown when `IsPreviewMode` is true:
   - The active cleaning panel's IsVisible becomes `{Binding !IsShowingResults}` AND NOT IsPreviewMode (add `!IsPreviewMode` condition -- use a MultiBinding or just keep existing since IsShowingResults will be true in preview mode)
   - Actually, simpler approach: the preview panel replaces the results panel when IsPreviewMode is true:
     - Results panel: IsVisible="{Binding IsShowingResults}" AND NOT IsPreviewMode
     - Preview panel: IsVisible="{Binding IsPreviewMode}"
     - Active panel: IsVisible="{Binding !IsShowingResults}" (unchanged -- preview sets IsShowingResults=true so active hides)

   Preview panel layout:
   - Row 0: Header "Dry-Run Preview" (FontSize 20, FontWeight Bold, Blue/Info color #1565C0)
   - Row 1: Disclaimer banner (Background #E3F2FD, BorderBrush #1565C0, text: PreviewDisclaimer)
   - Row 2: Summary bar showing "X will be cleaned, Y will be skipped"
   - Row 3: ItemsControl listing DryRunResults with:
     - Plugin name
     - Status text: "Will clean" (green #2D7D46) or "Will skip" (orange #E65100)
     - Reason text (for skipped plugins, show the reason; for clean plugins, show "Ready for cleaning")
   - Row 4: Close button (same as results panel)

   The counter badges (ITM/UDR/Nav) and Stop button are NOT visible in preview mode (they only show in the active cleaning panel which is hidden when IsShowingResults=true).

   Update the ProgressWindow title conditionally: when IsPreviewMode is true, show "Dry-Run Preview" instead of "Cleaning Progress". Bind the Title property if Avalonia supports it, otherwise set it in code-behind or ProgressWindow.axaml.cs when DataContext is set.

IMPORTANT: Per user decision, the preview reuses the existing ProgressWindow -- do NOT create a separate window class. The IsPreviewMode flag switches the UI between cleaning and preview display.
  </action>
  <verify>
    `dotnet build` succeeds. Inspect MainWindow.axaml has Preview button. Inspect ProgressWindow.axaml has preview panel with disclaimer. Inspect ProgressViewModel has IsPreviewMode and DryRunResults. Inspect MainWindowViewModel has PreviewCommand.
  </verify>
  <done>
    Preview button on main window triggers dry-run, results display in ProgressWindow with "Dry-Run Preview" header, disclaimer banner, and per-plugin "Will clean"/"Will skip: [reason]" entries. No counter badges or stop button in preview mode.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` completes without errors
2. DryRunResult model has WillClean and WillSkip statuses with reason strings
3. ICleaningOrchestrator.RunDryRunAsync is defined and implemented
4. MainWindow has Preview button alongside Start Cleaning
5. ProgressWindow has preview panel with disclaimer and per-plugin results
6. Preview mode hides ITM/UDR/Nav badges and Stop button
7. ProgressViewModel.IsPreviewMode controls panel visibility
</verification>

<success_criteria>
- User can click Preview to see which plugins will be cleaned or skipped
- Dry-run does NOT invoke xEdit
- Results are clearly labeled as preview with disclaimer about ITM/UDR limitations
- Counter badges and Stop button do not appear in preview mode
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-safety-features/05-01-SUMMARY.md`
</output>
