---
phase: 03-real-time-feedback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/Services/Cleaning/IXEditLogFileService.cs
  - AutoQAC/Services/Cleaning/XEditLogFileService.cs
  - AutoQAC/Models/CleaningResult.cs
  - AutoQAC/Models/PluginCleaningResult.cs
  - AutoQAC/Services/State/IStateService.cs
  - AutoQAC/Services/State/StateService.cs
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
autonomous: true

must_haves:
  truths:
    - "After each plugin completes, its cleaning stats (ITM/UDR/Nav counts) are parsed from the xEdit log file"
    - "Per-plugin results are emitted through a DetailedPluginResult observable on IStateService"
    - "If the log file cannot be read, a warning is recorded on the result and cleaning continues"
    - "Log file staleness is detected by comparing modification time to process start time"
  artifacts:
    - path: "AutoQAC/Services/Cleaning/IXEditLogFileService.cs"
      provides: "Interface for log file path computation and reading"
      exports: ["IXEditLogFileService"]
    - path: "AutoQAC/Services/Cleaning/XEditLogFileService.cs"
      provides: "Log file reading with retry on IOException"
      exports: ["XEditLogFileService"]
    - path: "AutoQAC/Services/State/IStateService.cs"
      provides: "DetailedPluginResult observable declaration"
      contains: "IObservable<PluginCleaningResult> DetailedPluginResult"
    - path: "AutoQAC/Services/State/StateService.cs"
      provides: "DetailedPluginResult Subject emitting per-plugin results"
      contains: "DetailedPluginResult"
  key_links:
    - from: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      to: "IXEditLogFileService"
      via: "constructor injection + ReadLogFileAsync call after each plugin"
      pattern: "_logFileService\\.ReadLogFileAsync"
    - from: "AutoQAC/Services/State/StateService.cs"
      to: "PluginCleaningResult"
      via: "Subject.OnNext in AddDetailedCleaningResult"
      pattern: "_detailedPluginResultSubject\\.OnNext"
---

<objective>
Build the backend pipeline for xEdit log file parsing and per-plugin result streaming.

Purpose: After each plugin's xEdit process exits, read the xEdit log file from disk (not stdout), parse cleaning statistics using the existing XEditOutputParser, and emit per-plugin results through a new DetailedPluginResult observable. This is the data backbone that the progress UI (Plan 03-02) will subscribe to for live counter badges.

Output: New IXEditLogFileService, enriched IStateService with DetailedPluginResult observable, CleaningOrchestrator wired to parse log files and emit results.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-feedback/03-RESEARCH.md

Key existing files to read before implementing:
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/CleaningService.cs
@AutoQAC/Services/Cleaning/XEditOutputParser.cs
@AutoQAC/Services/Cleaning/ICleaningService.cs
@AutoQAC/Services/State/IStateService.cs
@AutoQAC/Services/State/StateService.cs
@AutoQAC/Models/CleaningResult.cs
@AutoQAC/Models/PluginCleaningResult.cs
@AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create XEditLogFileService and enrich models</name>
  <files>
    AutoQAC/Services/Cleaning/IXEditLogFileService.cs
    AutoQAC/Services/Cleaning/XEditLogFileService.cs
    AutoQAC/Models/CleaningResult.cs
    AutoQAC/Models/PluginCleaningResult.cs
  </files>
  <action>
    1. Create `IXEditLogFileService.cs` with two methods:
       - `string GetLogFilePath(string xEditExecutablePath)` -- computes `{STEM_UPPERCASE}_log.txt` in same directory as xEdit executable
       - `Task<(List<string> lines, string? error)> ReadLogFileAsync(string xEditExecutablePath, DateTime processStartTime, CancellationToken ct = default)` -- reads the log file with staleness detection and retry

    2. Create `XEditLogFileService.cs` implementing the interface:
       - `GetLogFilePath`: `Path.GetDirectoryName` + `Path.GetFileNameWithoutExtension(...).ToUpperInvariant()` + `$"{stem}_log.txt"`
       - `ReadLogFileAsync`:
         a. Compute log path via GetLogFilePath
         b. If file doesn't exist, return empty list + error "Log file not found: {path}"
         c. Check `File.GetLastWriteTimeUtc(logPath)` against `processStartTime.ToUniversalTime()`. If log file is OLDER than process start, return empty list + error "Log file is stale (predates this cleaning run)"
         d. Try `File.ReadAllLinesAsync(logPath, ct)`. On `IOException`, wait 200ms (`Task.Delay(200, ct)`), retry once. If second attempt also throws, return empty list + error "Failed to read log file: {ex.Message}"
         e. On success, return (lines.ToList(), null)
       - Inject `ILoggingService` for debug logging

    3. Add `LogParseWarning` property to `CleaningResult.cs`:
       ```csharp
       public string? LogParseWarning { get; init; }
       ```

    4. Add `LogParseWarning` property to `PluginCleaningResult.cs`:
       ```csharp
       public string? LogParseWarning { get; init; }
       ```
       Also add a computed `HasLogParseWarning` property:
       ```csharp
       public bool HasLogParseWarning => !string.IsNullOrEmpty(LogParseWarning);
       ```
  </action>
  <verify>
    `dotnet build` succeeds with no errors. The new interface and implementation compile correctly. The model changes are backward-compatible (init properties with defaults).
  </verify>
  <done>
    IXEditLogFileService interface exists with GetLogFilePath and ReadLogFileAsync methods. XEditLogFileService implements log path computation ({STEM_UPPERCASE}_log.txt convention), staleness detection, IOException retry with 200ms delay. CleaningResult and PluginCleaningResult have LogParseWarning property.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DetailedPluginResult observable and wire orchestrator</name>
  <files>
    AutoQAC/Services/State/IStateService.cs
    AutoQAC/Services/State/StateService.cs
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  </files>
  <action>
    1. In `IStateService.cs`, add a new observable:
       ```csharp
       /// <summary>
       /// Emits a detailed result for each plugin as it completes cleaning.
       /// Subscribers receive per-plugin ITM/UDR/Nav stats immediately after each plugin finishes.
       /// </summary>
       IObservable<PluginCleaningResult> DetailedPluginResult { get; }
       ```

    2. In `StateService.cs`:
       - Add `private readonly Subject<PluginCleaningResult> _detailedPluginResultSubject = new();`
       - Expose: `public IObservable<PluginCleaningResult> DetailedPluginResult => _detailedPluginResultSubject.AsObservable();`
       - In `AddDetailedCleaningResult`, after adding to `_currentSessionResults`, emit: `_detailedPluginResultSubject.OnNext(result);`
       - In `Dispose`, add: `_detailedPluginResultSubject.Dispose();`

    3. In `CleaningOrchestrator.cs`:
       - Add `IXEditLogFileService` as a constructor dependency (add field `_logFileService`)
       - After each plugin's `CleanPluginAsync` completes (after `pluginStopwatch.Stop()`), if `result.Success` and `result.Status == CleaningStatus.Cleaned`:
         a. Read the xEdit log file: `var (logLines, logError) = await _logFileService.ReadLogFileAsync(config.XEditExecutablePath!, pluginStopwatch.StartTimeStamp... )` -- NOTE: The processStartTime should be captured BEFORE calling CleanPluginAsync. Add `var pluginStartTime = DateTime.UtcNow;` before the retry do-while loop.
         b. If logError is null and logLines has content, parse: `var logStats = _outputParser.ParseOutput(logLines);` -- use the EXISTING `_outputParser` field (it's `IXEditOutputParser`, already injected via `CleaningService` -- wait, it's on CleaningService not CleaningOrchestrator).

         CORRECTION: The orchestrator does NOT have IXEditOutputParser. Add it as a new dependency:
         - Add `private readonly IXEditOutputParser _outputParser;` field
         - Add to constructor: `IXEditOutputParser outputParser`

         c. If log parsing succeeded, use `logStats` as the statistics for the result instead of (or in addition to) the stdout-based stats from CleaningResult.
         d. If logError is not null, set `LogParseWarning` on the PluginCleaningResult.

       - Modify the PluginCleaningResult construction to prefer log-file-based stats when available:
         ```csharp
         // After log file reading
         CleaningStatistics? finalStats = result.Statistics; // stdout-based (existing)
         string? logWarning = null;

         if (result.Success && result.Status == CleaningStatus.Cleaned)
         {
             var (logLines, logError) = await _logFileService.ReadLogFileAsync(
                 config.XEditExecutablePath!, pluginStartTime, cts.Token).ConfigureAwait(false);

             if (logError == null && logLines.Count > 0)
             {
                 finalStats = _outputParser.ParseOutput(logLines);
             }
             else if (logError != null)
             {
                 logWarning = logError;
                 _logger.Warning("Log parse warning for {Plugin}: {Error}", plugin.FileName, logError);
                 // Keep stdout-based stats as fallback
             }
         }

         var pluginCleaningResult = new PluginCleaningResult
         {
             PluginName = plugin.FileName,
             Status = result.Status,
             Success = result.Success,
             Message = ..., // existing logic
             Duration = pluginStopwatch.Elapsed,
             Statistics = finalStats,
             LogParseWarning = logWarning
         };
         ```

    4. In `ServiceCollectionExtensions.cs`, in `AddBusinessLogic`:
       Add: `services.AddSingleton<IXEditLogFileService, XEditLogFileService>();`
       Place it near the other cleaning-related registrations (after IXEditOutputParser).

    IMPORTANT: The orchestrator needs `pluginStartTime` captured BEFORE the cleaning call to detect stale logs. Add `var pluginStartTime = DateTime.UtcNow;` right before the `do { ... } while` retry loop.
  </action>
  <verify>
    `dotnet build` succeeds. Verify the orchestrator constructor now accepts `IXEditLogFileService` and `IXEditOutputParser`. Verify `StateService.AddDetailedCleaningResult` calls `_detailedPluginResultSubject.OnNext`. Run `dotnet test` to check for any regressions (existing tests may need mock updates for the new constructor parameters).
  </verify>
  <done>
    IStateService exposes DetailedPluginResult observable. StateService emits PluginCleaningResult through the observable when AddDetailedCleaningResult is called. CleaningOrchestrator reads the xEdit log file after each plugin completes, parses stats with XEditOutputParser, and prefers log-based stats over stdout stats. Log parse failures set LogParseWarning on the result. IXEditLogFileService is registered in DI. All existing tests pass (with mock updates for new constructor parameters).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` -- project compiles with no errors
2. `dotnet test` -- all existing tests pass (may need mock updates for new CleaningOrchestrator constructor parameters)
3. Verify `IXEditLogFileService` is registered in DI by checking `ServiceCollectionExtensions.cs`
4. Verify `DetailedPluginResult` observable is wired: `StateService.AddDetailedCleaningResult` -> `_detailedPluginResultSubject.OnNext`
5. Verify log file path convention: SSEEdit.exe -> SSEEDIT_log.txt (uppercase stem + _log.txt)
</verification>

<success_criteria>
- IXEditLogFileService computes correct log file paths ({STEM_UPPERCASE}_log.txt)
- XEditLogFileService handles missing files, stale logs, and IOException with retry
- CleaningOrchestrator reads log file after each successful clean and parses stats
- DetailedPluginResult observable emits PluginCleaningResult per plugin
- LogParseWarning is populated when log file reading fails
- All existing tests pass with updated mocks
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-feedback/03-01-SUMMARY.md`
</output>
