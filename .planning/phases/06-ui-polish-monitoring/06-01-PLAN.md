---
phase: 06-ui-polish-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AutoQAC/ViewModels/MainWindowViewModel.cs
  - AutoQAC/ViewModels/MainWindow/ConfigurationViewModel.cs
  - AutoQAC/ViewModels/MainWindow/PluginListViewModel.cs
  - AutoQAC/ViewModels/MainWindow/CleaningCommandsViewModel.cs
  - AutoQAC/Views/MainWindow.axaml
  - AutoQAC/Views/MainWindow.axaml.cs
  - AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  - AutoQAC/App.axaml.cs
  - AutoQAC.Tests/ViewModels/MainWindowViewModelTests.cs
  - AutoQAC.Tests/ViewModels/MainWindowViewModelInitializationTests.cs
autonomous: true

must_haves:
  truths:
    - "Application behaves identically to before the split -- all buttons, bindings, commands, and interactions work unchanged"
    - "All existing tests pass (migrated to target new sub-ViewModels where appropriate)"
    - "dotnet build succeeds with zero compiled binding errors"
  artifacts:
    - path: "AutoQAC/ViewModels/MainWindow/ConfigurationViewModel.cs"
      provides: "Path management, file dialogs, path validation, game selection, auto-save subscriptions"
      min_lines: 200
    - path: "AutoQAC/ViewModels/MainWindow/PluginListViewModel.cs"
      provides: "Plugin collection, select/deselect all, skip list subscription, refresh logic"
      min_lines: 80
    - path: "AutoQAC/ViewModels/MainWindow/CleaningCommandsViewModel.cs"
      provides: "Start/Stop/Preview commands, validation errors, status text, pre-clean validation"
      min_lines: 150
    - path: "AutoQAC/ViewModels/MainWindowViewModel.cs"
      provides: "Slim orchestrator exposing sub-VMs, Interactions, cross-VM wiring"
      min_lines: 80
  key_links:
    - from: "AutoQAC/Views/MainWindow.axaml"
      to: "AutoQAC/ViewModels/MainWindow/ConfigurationViewModel.cs"
      via: "XAML binding path prefix Configuration."
      pattern: "Binding Configuration\\."
    - from: "AutoQAC/Views/MainWindow.axaml"
      to: "AutoQAC/ViewModels/MainWindow/PluginListViewModel.cs"
      via: "XAML binding path prefix PluginList."
      pattern: "Binding PluginList\\."
    - from: "AutoQAC/Views/MainWindow.axaml"
      to: "AutoQAC/ViewModels/MainWindow/CleaningCommandsViewModel.cs"
      via: "XAML binding path prefix Commands."
      pattern: "Binding Commands\\."
    - from: "AutoQAC/ViewModels/MainWindowViewModel.cs"
      to: "Sub-ViewModels"
      via: "Parent Dispose calls sub-VM Dispose"
      pattern: "Configuration\\.Dispose|PluginList\\.Dispose|CleaningCommands\\.Dispose"
---

<objective>
Decompose the 1186-line MainWindowViewModel into three focused sub-ViewModels using functional grouping by feature area, with parent mediation for cross-VM communication. All Interactions stay on the parent (registered in MainWindow.axaml.cs code-behind). Each sub-VM manages its own CompositeDisposable. Existing tests are migrated to target the new sub-ViewModels directly.

Purpose: The current MainWindowViewModel is bloated with 8 constructor dependencies, 20+ commands, and 29 properties mixing configuration, plugin list, and cleaning concerns. Decomposing it improves maintainability and testability for future development.

Output: Three new sub-ViewModel files in AutoQAC/ViewModels/MainWindow/, a slim parent orchestrator, updated XAML bindings, and migrated tests.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ui-polish-monitoring/06-RESEARCH.md

Key files to read before starting:
@AutoQAC/ViewModels/MainWindowViewModel.cs
@AutoQAC/Views/MainWindow.axaml
@AutoQAC/Views/MainWindow.axaml.cs
@AutoQAC/App.axaml.cs
@AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
@AutoQAC.Tests/ViewModels/MainWindowViewModelTests.cs
@AutoQAC.Tests/ViewModels/MainWindowViewModelInitializationTests.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract sub-ViewModels and slim down MainWindowViewModel</name>
  <files>
    AutoQAC/ViewModels/MainWindow/ConfigurationViewModel.cs
    AutoQAC/ViewModels/MainWindow/PluginListViewModel.cs
    AutoQAC/ViewModels/MainWindow/CleaningCommandsViewModel.cs
    AutoQAC/ViewModels/MainWindowViewModel.cs
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
    AutoQAC/App.axaml.cs
  </files>
  <action>
    **Step 1: Create AutoQAC/ViewModels/MainWindow/ directory and the three sub-ViewModels.**

    **ConfigurationViewModel** (~550 lines) -- inherits ViewModelBase, implements IDisposable:
    - Properties: LoadOrderPath, XEditPath, Mo2Path, Mo2ModeEnabled, PartialFormsEnabled, DisableSkipListsEnabled, SelectedGame, AvailableGames, IsMutagenSupported (OAPH), RequiresLoadOrderFile (OAPH), GameDataFolder, HasGameDataFolderOverride, IsXEditPathValid, IsMo2PathValid, IsLoadOrderPathValid, IsGameDataFolderValid, HasMigrationWarning, MigrationWarningMessage
    - Commands: ConfigureLoadOrderCommand, ConfigureXEditCommand, ConfigureMo2Command, ConfigureGameDataFolderCommand, ClearGameDataFolderOverrideCommand, TogglePartialFormsCommand, DismissMigrationWarningCommand
    - Methods: InitializeAsync, ConfigureLoadOrderAsync, ConfigureXEditAsync, ConfigureMo2Async, ConfigureGameDataFolderAsync, ClearGameDataFolderOverrideAsync, SaveConfigurationAsync, RefreshPluginsForGameAsync, ApplySkipListStatus (static), ShowMigrationWarning
    - Subscriptions: path validation (xEdit, MO2, LoadOrder, DataFolder), Mo2Mode auto-save, game selection auto-save + plugin refresh, skip list changes, DisableSkipLists auto-save
    - Constructor params: IConfigurationService, IStateService, ILoggingService, IFileDialogService, IMessageDialogService, IPluginValidationService, IPluginLoadingService
    - ConfigurationViewModel needs a reference to IPluginListUpdater (interface on PluginListViewModel or a callback) so it can update plugins when game selection changes. Use an Action<List<PluginInfo>> callback set by the parent, or have it call _stateService.SetPluginsToClean directly (which PluginListViewModel subscribes to via StateChanged).
    - The simplest approach: ConfigurationViewModel updates plugins by calling _stateService.SetPluginsToClean() and _stateService.UpdateState(). PluginListViewModel reacts to StateChanged. No direct cross-VM reference needed.

    **PluginListViewModel** (~200 lines) -- inherits ViewModelBase, implements IDisposable:
    - Properties: PluginsToClean (ObservableCollection), SelectedPlugin
    - Commands: SelectAllCommand, DeselectAllCommand
    - State subscription: OnStateChanged filters PluginsToClean (removes IsInSkipList), updates collection
    - Constructor params: IStateService
    - The canSelectPlugins observable needs IsCleaning (from state) and hasPlugins (from PluginsToClean count). Both are available from IStateService.StateChanged.

    **CleaningCommandsViewModel** (~400 lines) -- inherits ViewModelBase, implements IDisposable:
    - Properties: StatusText, ValidationErrors (ObservableCollection), HasValidationErrors, IsCleaning (OAPH), CanStartCleaning (OAPH)
    - Commands: StartCleaningCommand, StopCleaningCommand, PreviewCommand, ExitCommand, ShowAboutCommand, ResetSettingsCommand, ShowSettingsCommand, ShowSkipListCommand, RestoreBackupsCommand, DismissValidationCommand
    - Methods: StartCleaningAsync, RunPreviewAsync, ValidatePreClean, HandleStopAsync, HandleTimeoutRetryAsync, HandleBackupFailureAsync, ShowRestoreAsync, ShowSettingsAsync, ShowSkipListAsync, ResetSettingsAsync, Exit, ShowAbout
    - Constructor params: IStateService, ICleaningOrchestrator, IConfigurationService, ILoggingService, IMessageDialogService, IPluginLoadingService
    - **Interactions**: CleaningCommandsViewModel needs to trigger Interactions (ShowProgressInteraction, ShowPreviewInteraction, etc.) but Interactions are registered in MainWindow.axaml.cs which holds a reference to MainWindowViewModel. Solution: CleaningCommandsViewModel exposes IObservable events (e.g., event Action<Unit> ShowProgressRequested). Parent subscribes to these and forwards to its Interactions. OR simpler: pass the Interaction objects into CleaningCommandsViewModel's constructor from the parent. Since Interactions are just objects, they can be passed down.
    - **Decision (Claude's discretion)**: Pass Interaction references from parent to CleaningCommandsViewModel constructor. This avoids extra event plumbing and keeps the pattern simple. The Interactions are still "owned" by MainWindowViewModel conceptually (registered in MainWindow.axaml.cs), but CleaningCommandsViewModel can call Handle() on them.
    - canStart observable: needs hasPlugins from IStateService.StateChanged and XEditPath from ConfigurationViewModel. Use parent mediation: parent creates the canStart observable by combining CleaningCommands.WhenAnyValue(x => x.IsCleaning) with Configuration.WhenAnyValue(x => x.XEditPath) and PluginList.PluginsToClean count. Then passes canStart to CleaningCommandsViewModel as a constructor parameter (IObservable<bool> canStart). CleaningCommandsViewModel uses it for StartCleaningCommand and PreviewCommand.
    - **Alternatively** (simpler): CleaningCommandsViewModel reads hasPlugins from IStateService.StateChanged directly, and XEditPath from IStateService.StateChanged (state.XEditExecutablePath). This avoids cross-VM reactive chains entirely. IsCleaning already comes from IStateService.StateChanged. All three inputs are available from IStateService alone. Use this approach.

    **MainWindowViewModel** (~150 lines) -- slim orchestrator:
    - Public properties: Configuration, PluginList, CleaningCommands (sub-VMs)
    - Interactions: ShowProgressInteraction, ShowPreviewInteraction, ShowCleaningResultsInteraction, ShowSettingsInteraction, ShowSkipListInteraction, ShowRestoreInteraction (stay here, passed to CleaningCommandsViewModel)
    - Constructor: Creates sub-VMs, passes dependencies and Interaction references
    - Dispose: Calls Dispose on all three sub-VMs
    - No business logic -- pure composition

    **Step 2: Update DI registration in ServiceCollectionExtensions.cs**
    - Sub-ViewModels do NOT need DI registration (created directly by MainWindowViewModel)
    - MainWindowViewModel registration remains as-is

    **Step 3: Update App.axaml.cs**
    - The RunMigrationAsync call to viewModel.ShowMigrationWarning needs to be updated to viewModel.Configuration.ShowMigrationWarning (since that method moves to ConfigurationViewModel)

    **CRITICAL: Compiled bindings pitfall.** The .csproj has AvaloniaUseCompiledBindingsByDefault=true. All XAML binding paths must be updated atomically in Task 2. Ensure ConfigurationViewModel, PluginListViewModel, CleaningCommandsViewModel are public classes so compiled bindings can resolve them.
  </action>
  <verify>
    `dotnet build j:/AutoQACSharp` succeeds with zero errors. The three new files exist in AutoQAC/ViewModels/MainWindow/. MainWindowViewModel.cs is under 200 lines.
  </verify>
  <done>
    MainWindowViewModel is decomposed into ConfigurationViewModel, PluginListViewModel, and CleaningCommandsViewModel. Parent is a slim orchestrator. All sub-VMs compile. DI registration unchanged. App.axaml.cs updated for migration warning path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update XAML bindings and migrate tests</name>
  <files>
    AutoQAC/Views/MainWindow.axaml
    AutoQAC/Views/MainWindow.axaml.cs
    AutoQAC.Tests/ViewModels/MainWindowViewModelTests.cs
    AutoQAC.Tests/ViewModels/MainWindowViewModelInitializationTests.cs
  </files>
  <action>
    **Step 1: Update MainWindow.axaml binding paths.**

    All bindings that targeted MainWindowViewModel properties must now go through sub-VM prefixes. The x:DataType on the Window element stays as MainWindowViewModel. Sub-controls can use x:DataType overrides if needed for compiled binding resolution, but the simplest approach is dotted path bindings from the parent.

    Binding path mapping (all bindings in MainWindow.axaml must be updated):
    - Configuration properties: `{Binding XEditPath}` -> `{Binding Configuration.XEditPath}`, `{Binding LoadOrderPath}` -> `{Binding Configuration.LoadOrderPath}`, etc.
    - Configuration commands: `{Binding ConfigureXEditCommand}` -> `{Binding Configuration.ConfigureXEditCommand}`, etc.
    - Plugin list properties: `{Binding PluginsToClean}` -> `{Binding PluginList.PluginsToClean}`, `{Binding SelectedPlugin}` -> `{Binding PluginList.SelectedPlugin}`
    - Plugin list commands: `{Binding SelectAllCommand}` -> `{Binding PluginList.SelectAllCommand}`, `{Binding DeselectAllCommand}` -> `{Binding PluginList.DeselectAllCommand}`
    - Cleaning commands: `{Binding StartCleaningCommand}` -> `{Binding Commands.StartCleaningCommand}`, `{Binding StopCleaningCommand}` -> `{Binding Commands.StopCleaningCommand}`, etc.
    - Cleaning properties: `{Binding StatusText}` -> `{Binding Commands.StatusText}`, `{Binding IsCleaning}` -> `{Binding Commands.IsCleaning}`, `{Binding CanStartCleaning}` -> `{Binding Commands.CanStartCleaning}`, `{Binding HasValidationErrors}` -> `{Binding Commands.HasValidationErrors}`, `{Binding ValidationErrors}` -> `{Binding Commands.ValidationErrors}`
    - Menu commands: `{Binding ExitCommand}` -> `{Binding Commands.ExitCommand}`, `{Binding ShowSettingsCommand}` -> `{Binding Commands.ShowSettingsCommand}`, `{Binding ShowSkipListCommand}` -> `{Binding Commands.ShowSkipListCommand}`, `{Binding ShowAboutCommand}` -> `{Binding Commands.ShowAboutCommand}`
    - Migration banner: `{Binding HasMigrationWarning}` -> `{Binding Configuration.HasMigrationWarning}`, etc.
    - Other config properties: `{Binding Mo2ModeEnabled}` -> `{Binding Configuration.Mo2ModeEnabled}`, `{Binding PartialFormsEnabled}` -> `{Binding Configuration.PartialFormsEnabled}`, etc.

    Build after XAML changes to catch any compiled binding errors immediately: `dotnet build`.

    **Step 2: Update MainWindow.axaml.cs**
    - Interaction registration stays the same (viewModel.ShowProgressInteraction etc. -- these are still on MainWindowViewModel)
    - ShowRestoreAsync accesses vm.GameDataFolder -- update to vm.Configuration.GameDataFolder

    **Step 3: Migrate tests.**

    For MainWindowViewModelTests.cs:
    - Tests that verify ConfigureLoadOrderCommand behavior should now construct ConfigurationViewModel directly with appropriate mocks, or construct MainWindowViewModel and access the command through vm.Configuration.ConfigureLoadOrderCommand
    - Tests that verify StartCleaningCommand should access through vm.Commands.StartCleaningCommand
    - Tests that verify CanStartCleaning, IsCleaning, StopCleaningCommand should access through vm.Commands
    - Tests that verify SelectedGame, IsMutagenSupported should access through vm.Configuration
    - Tests that verify state synchronization (OnStateChanged) need to test that sub-VMs update correctly
    - The simplest migration strategy: keep constructing MainWindowViewModel (which creates sub-VMs internally), and update property/command access paths. This minimizes test rewriting while still exercising the new structure.
    - Example: `vm.CanStartCleaning` -> `vm.Commands.CanStartCleaning`, `vm.XEditPath` -> `vm.Configuration.XEditPath`, `vm.LoadOrderPath` -> `vm.Configuration.LoadOrderPath`

    For MainWindowViewModelInitializationTests.cs:
    - Same approach -- construct MainWindowViewModel, access through sub-VM properties

    All tests must pass: `dotnet test j:/AutoQACSharp`
  </action>
  <verify>
    `dotnet build j:/AutoQACSharp` succeeds with zero compiled binding warnings/errors. `dotnet test j:/AutoQACSharp` passes all tests.
  </verify>
  <done>
    All XAML bindings updated with sub-VM path prefixes. All existing tests migrated and passing. Application builds cleanly with compiled bindings.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build j:/AutoQACSharp` -- zero errors, zero binding warnings
2. `dotnet test j:/AutoQACSharp` -- all existing tests pass
3. MainWindowViewModel.cs is under 200 lines (slim orchestrator)
4. Three sub-VM files exist in AutoQAC/ViewModels/MainWindow/
5. No property or command remains directly on MainWindowViewModel (except sub-VM properties and Interactions)
</verification>

<success_criteria>
- MainWindowViewModel decomposed into ConfigurationViewModel (~550 lines), PluginListViewModel (~200 lines), CleaningCommandsViewModel (~400 lines)
- Parent MainWindowViewModel is a slim orchestrator under 200 lines
- All XAML bindings use dotted path notation (Configuration.X, PluginList.X, Commands.X)
- All existing tests pass targeting the new structure
- Application compiles with AvaloniaUseCompiledBindingsByDefault=true and zero binding errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-ui-polish-monitoring/06-01-SUMMARY.md`
</output>
