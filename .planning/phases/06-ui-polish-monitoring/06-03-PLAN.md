---
phase: 06-ui-polish-monitoring
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - AutoQAC/Services/Monitoring/IHangDetectionService.cs
  - AutoQAC/Services/Monitoring/HangDetectionService.cs
  - AutoQAC/ViewModels/ProgressViewModel.cs
  - AutoQAC/Views/ProgressWindow.axaml
  - AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  - AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
  - AutoQAC.Tests/Services/HangDetectionServiceTests.cs
autonomous: true

must_haves:
  truths:
    - "When xEdit CPU usage is near-zero for 60 seconds, an inline warning banner appears in the progress window with Wait and Kill buttons"
    - "If xEdit resumes CPU activity after the warning appears, the warning auto-dismisses without user action"
    - "Clicking Kill terminates the xEdit process and the cleaning session continues to the next plugin or completes"
    - "Clicking Wait dismisses the warning and resumes normal monitoring (warning will reappear if xEdit remains hung)"
    - "Hang detection does not interfere with normal cleaning operations"
  artifacts:
    - path: "AutoQAC/Services/Monitoring/IHangDetectionService.cs"
      provides: "Interface for hang detection observable"
      exports: ["IHangDetectionService"]
    - path: "AutoQAC/Services/Monitoring/HangDetectionService.cs"
      provides: "CPU polling implementation using Process.TotalProcessorTime delta"
      min_lines: 50
    - path: "AutoQAC.Tests/Services/HangDetectionServiceTests.cs"
      provides: "Unit tests for hang detection logic"
      min_lines: 30
  key_links:
    - from: "AutoQAC/Services/Cleaning/CleaningOrchestrator.cs"
      to: "AutoQAC/Services/Monitoring/IHangDetectionService.cs"
      via: "Subscribes to MonitorProcess during cleaning"
      pattern: "_hangDetection\\.MonitorProcess"
    - from: "AutoQAC/ViewModels/ProgressViewModel.cs"
      to: "ProgressWindow.axaml"
      via: "IsHangWarningVisible, DismissHangWarningCommand, KillHungProcessCommand"
      pattern: "IsHangWarningVisible|DismissHangWarningCommand|KillHungProcessCommand"
---

<objective>
Implement CPU-based hang detection for xEdit processes with an inline warning banner in the progress window. When xEdit appears unresponsive (near-zero CPU for 60 seconds), display a non-intrusive warning with Wait and Kill options. Auto-dismiss if xEdit resumes activity.

Purpose: xEdit occasionally hangs during plugin cleaning (especially on large or corrupted plugins). Users currently have no indication that xEdit is stuck, leading to indefinite waits. Hang detection with an inline notification gives users diagnostic awareness and a clean escape path.

Output: HangDetectionService (polling-based CPU monitor), ProgressViewModel hang warning properties/commands, ProgressWindow inline warning banner XAML, CleaningOrchestrator integration.
</objective>

<execution_context>
@C:\Users\evild\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\evild\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ui-polish-monitoring/06-RESEARCH.md
@.planning/phases/06-ui-polish-monitoring/06-01-SUMMARY.md

Key files to read before starting:
@AutoQAC/ViewModels/ProgressViewModel.cs
@AutoQAC/Views/ProgressWindow.axaml
@AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
@AutoQAC/Services/Cleaning/ICleaningOrchestrator.cs
@AutoQAC/Services/State/IStateService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: HangDetectionService and DI registration</name>
  <files>
    AutoQAC/Services/Monitoring/IHangDetectionService.cs
    AutoQAC/Services/Monitoring/HangDetectionService.cs
    AutoQAC/Infrastructure/ServiceCollectionExtensions.cs
    AutoQAC.Tests/Services/HangDetectionServiceTests.cs
  </files>
  <action>
    **Step 1: Create AutoQAC/Services/Monitoring/ directory.**

    **Step 2: Create IHangDetectionService.cs.**

    ```csharp
    public interface IHangDetectionService
    {
        /// <summary>
        /// Monitor a process for hang detection. Emits true when the process
        /// appears hung (CPU near-zero for threshold duration), false when it resumes.
        /// Completes when the process exits.
        /// </summary>
        IObservable<bool> MonitorProcess(Process process);
    }
    ```

    **Step 3: Create HangDetectionService.cs.**

    Implements IHangDetectionService. Constants (private):
    - `PollIntervalMs = 5000` (check every 5 seconds)
    - `HangThresholdMs = 60_000` (60 seconds of near-zero CPU per locked decision)
    - `CpuThreshold = 0.5` (less than 0.5% CPU = near-zero)

    MonitorProcess implementation using Observable.Create<bool>:
    1. Record initial `process.TotalProcessorTime` and `DateTime.UtcNow`
    2. Use Observable.Interval(TimeSpan.FromMilliseconds(PollIntervalMs))
    3. On each tick:
       a. Check `process.HasExited` -- if true, observer.OnCompleted(), return
       b. Read `process.TotalProcessorTime` (wrap in try/catch InvalidOperationException for race condition -- if caught, OnCompleted())
       c. Calculate CPU delta: `(currentCpuTime - lastCpuTime).TotalMilliseconds / elapsed.TotalMilliseconds * 100.0`
       d. If cpuPercent < CpuThreshold: accumulate nearZeroDuration. If nearZeroDuration >= HangThresholdMs and NOT already flagged: emit true (hung detected), set wasHung = true
       e. If cpuPercent >= CpuThreshold: if wasHung, emit false (resumed), set wasHung = false, reset nearZeroDuration to zero
       f. Update lastCpuTime and lastCheckTime
    4. Return the timer subscription as the disposable

    The service should be stateless between calls -- all monitoring state is captured in the Observable.Create closure. This makes it safe to call MonitorProcess multiple times sequentially.

    Inject ILoggingService for debug-level logging of CPU readings (helps troubleshoot false positives). Log at Debug level only:
    - "Hang detection: CPU {Cpu}% over last {Interval}s for process {PID}"
    - "Hang detection: xEdit appears hung (near-zero CPU for {Duration}s)"
    - "Hang detection: xEdit resumed (CPU {Cpu}%)"

    **Step 4: Register in DI.**

    In ServiceCollectionExtensions.AddBusinessLogic(), add:
    ```csharp
    services.AddSingleton<IHangDetectionService, HangDetectionService>();
    ```

    **Step 5: Write unit tests.**

    Create AutoQAC.Tests/Services/HangDetectionServiceTests.cs. Testing with real Process objects is fragile, so test the observable behavior using a mock/wrapper approach OR test with the real service using a known process. The simplest approach for testable design:

    Make the timing constants configurable via constructor parameters with defaults (or use an internal TestableHangDetectionService subclass). Alternatively, test at a higher level by verifying the service compiles and the observable contract is correct.

    Write tests:
    - Test that MonitorProcess returns an IObservable (not null)
    - Test that the observable completes when given a process that has already exited
    - Test with a short-lived process (e.g., `dotnet --version`) that the observable completes without emitting true (process exits before threshold)

    Be pragmatic about test coverage here -- the real validation will be empirical (running against xEdit). Focus on contract correctness and edge cases (process already exited, process exits during monitoring).
  </action>
  <verify>
    `dotnet build j:/AutoQACSharp` succeeds. `dotnet test j:/AutoQACSharp` passes all tests including new HangDetectionServiceTests. IHangDetectionService.cs and HangDetectionService.cs exist in AutoQAC/Services/Monitoring/.
  </verify>
  <done>
    HangDetectionService monitors process CPU usage via Process.TotalProcessorTime delta polling, emits true when near-zero CPU persists for 60 seconds, emits false when activity resumes, and completes when the process exits. Registered in DI. Basic tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: ProgressViewModel hang warning + ProgressWindow banner + Orchestrator wiring</name>
  <files>
    AutoQAC/ViewModels/ProgressViewModel.cs
    AutoQAC/Views/ProgressWindow.axaml
    AutoQAC/Services/Cleaning/CleaningOrchestrator.cs
  </files>
  <action>
    **Step 1: Add hang warning properties and commands to ProgressViewModel.**

    New properties:
    - `IsHangWarningVisible` (bool, reactive): True when hang is detected and user hasn't dismissed
    - `HangWarningDuration` (string, reactive): How long xEdit has been unresponsive (e.g., "60+ seconds")

    New commands:
    - `DismissHangWarningCommand`: ReactiveCommand.Create -- sets IsHangWarningVisible = false, sets _hangDismissed = true (prevents re-showing for current plugin)
    - `KillHungProcessCommand`: ReactiveCommand.CreateFromTask -- calls _orchestrator.ForceStopCleaningAsync(), sets IsHangWarningVisible = false

    Private state:
    - `_hangDismissed` (bool): Tracks whether user clicked "Wait" for current plugin. Reset in OnStateChanged when CurrentPlugin changes.
    - `_hangSubscription` (IDisposable?): Current hang monitoring subscription, disposed when cleaning stops or plugin changes.

    The ProgressViewModel needs access to IHangDetectionService and the current xEdit Process. Two approaches:

    **Approach A (recommended)**: Add an IObservable<bool> HangDetected property to IStateService or expose it through a new observable on the orchestrator. The orchestrator subscribes to IHangDetectionService when it starts a process and relays hang status through IStateService.

    **Approach B**: Pass IHangDetectionService to ProgressViewModel and have it subscribe directly. But ProgressViewModel doesn't have access to the Process object.

    **Go with Approach A**: The orchestrator already manages the Process lifecycle. Add to ICleaningOrchestrator:
    ```csharp
    /// <summary>
    /// Observable that emits hang detection status changes during cleaning.
    /// Emits true when xEdit appears hung, false when it resumes or a new plugin starts.
    /// </summary>
    IObservable<bool> HangDetected { get; }
    ```

    In CleaningOrchestrator implementation:
    - Add a Subject<bool> _hangDetected field
    - When starting each plugin's process, subscribe to _hangDetection.MonitorProcess(process)
    - Forward emissions to _hangDetected subject
    - On plugin change or cleaning end, emit false and dispose the monitoring subscription
    - Expose _hangDetected.AsObservable() as HangDetected property

    In ProgressViewModel constructor:
    - Subscribe to _orchestrator.HangDetected.ObserveOn(RxApp.MainThreadScheduler)
    - On true: if !_hangDismissed, set IsHangWarningVisible = true
    - On false: set IsHangWarningVisible = false, reset _hangDismissed = false

    Reset _hangDismissed when CurrentPlugin changes (in OnStateChanged).

    **Step 2: Add inline warning banner to ProgressWindow.axaml.**

    Add the hang warning banner in the active cleaning panel (between the summary bar row and the progress bar row, or between progress bar and completed list). The banner should be visible ONLY during active cleaning (not in results or preview mode).

    Per locked decision: inline warning banner in progress window with action buttons, NOT a modal dialog.

    ```xml
    <!-- Hang Detection Warning Banner -->
    <Border IsVisible="{Binding IsHangWarningVisible}"
            Background="#FFF3E0"
            BorderBrush="#E65100"
            BorderThickness="1"
            CornerRadius="4"
            Padding="10,8"
            Margin="0,8,0,0">
        <Grid ColumnDefinitions="Auto,*,Auto,Auto">
            <TextBlock Grid.Column="0"
                       Text="&#x26A0;"
                       FontSize="16"
                       VerticalAlignment="Center"
                       Margin="0,0,8,0" />
            <TextBlock Grid.Column="1"
                       Text="xEdit appears to be unresponsive"
                       TextWrapping="Wrap"
                       VerticalAlignment="Center"
                       Foreground="#BF360C" />
            <Button Grid.Column="2"
                    Content="Wait"
                    Command="{Binding DismissHangWarningCommand}"
                    Padding="8,3"
                    Margin="5,0"
                    VerticalAlignment="Center" />
            <Button Grid.Column="3"
                    Content="Kill"
                    Command="{Binding KillHungProcessCommand}"
                    Padding="8,3"
                    VerticalAlignment="Center" />
        </Grid>
    </Border>
    ```

    Insert this in the active cleaning Grid (the one with `IsVisible="{Binding !IsShowingResults}"`). Place it between Row 1 (summary bar) and Row 2 (progress bar) -- adjust RowDefinitions to add an Auto row for the banner. Update subsequent Grid.Row values.

    **Step 3: Wire CleaningOrchestrator.**

    Read CleaningOrchestrator.cs to understand the process lifecycle. Find where individual plugin processes are started. The orchestrator likely calls CleaningService.CleanPluginAsync which starts a Process.

    Two sub-approaches for getting the Process object:
    a. If CleaningService exposes the Process or a callback when it starts, use that
    b. If the orchestrator already tracks _currentProcess (from Phase 1's onProcessStarted callback), use that

    From STATE.md: "[01-01] PID file in AutoQAC Data/ directory" and the verification caught that CleaningService didn't forward the onProcessStarted callback. So _currentProcess should now be populated. Verify by reading the orchestrator code.

    In the orchestrator's per-plugin loop:
    1. After process starts (onProcessStarted callback fires), subscribe to _hangDetection.MonitorProcess(process)
    2. Forward hang/resume events to _hangDetected subject
    3. Before moving to next plugin, dispose the hang monitoring subscription and emit false on _hangDetected

    Add IHangDetectionService to CleaningOrchestrator constructor parameters.

    **Step 4: Update ProgressViewModel constructor** to accept ICleaningOrchestrator (already does) and subscribe to HangDetected observable.

    **Step 5: Ensure cleanup.** On ResetForNewSession, set IsHangWarningVisible = false and _hangDismissed = false.
  </action>
  <verify>
    `dotnet build j:/AutoQACSharp` succeeds. `dotnet test j:/AutoQACSharp` passes all tests. ProgressWindow.axaml contains the hang warning banner XAML. ProgressViewModel has IsHangWarningVisible, DismissHangWarningCommand, and KillHungProcessCommand. CleaningOrchestrator subscribes to IHangDetectionService.
  </verify>
  <done>
    When xEdit CPU is near-zero for 60 seconds, an inline warning banner appears in the progress window. Wait dismisses the warning (reappears if still hung after next threshold). Kill terminates xEdit. Banner auto-dismisses if xEdit resumes CPU activity. No interference with normal cleaning.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build j:/AutoQACSharp` -- zero errors
2. `dotnet test j:/AutoQACSharp` -- all tests pass (including new HangDetectionServiceTests)
3. IHangDetectionService and HangDetectionService exist in AutoQAC/Services/Monitoring/
4. ProgressWindow.axaml contains hang warning banner with Wait/Kill buttons
5. ProgressViewModel has IsHangWarningVisible property and DismissHangWarningCommand/KillHungProcessCommand
6. CleaningOrchestrator exposes HangDetected observable and subscribes to IHangDetectionService during cleaning
7. CleaningOrchestrator constructor accepts IHangDetectionService
</verification>

<success_criteria>
- HangDetectionService polls Process.TotalProcessorTime every 5 seconds, flags as hung after 60 seconds of less than 0.5% CPU
- Inline warning banner appears in progress window (not a modal dialog) when hang detected
- Wait button dismisses warning (monitoring continues, will re-flag if still hung)
- Kill button calls ForceStopCleaningAsync to terminate xEdit
- Auto-dismiss when xEdit resumes CPU activity
- No false positives during normal cleaning (60-second threshold is conservative)
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/06-ui-polish-monitoring/06-03-SUMMARY.md`
</output>
